// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/epoching/v1/genesis.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the epoching module's genesis state.
type GenesisState struct {
	// params are the current params of the state.
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// epochs contains all the epochs info
	Epochs []*Epoch `protobuf:"bytes,2,rep,name=epochs,proto3" json:"epochs,omitempty"`
	// queues contains all the epochs' queue
	Queues []*EpochQueue `protobuf:"bytes,3,rep,name=queues,proto3" json:"queues,omitempty"`
	// validator_sets is a slice containing all the
	// stored epochs' validator sets
	ValidatorSets []*EpochValidatorSet `protobuf:"bytes,4,rep,name=validator_sets,json=validatorSets,proto3" json:"validator_sets,omitempty"`
	// slashed_validator_sets is a slice containing all the
	// stored epochs' slashed validator sets
	SlashedValidatorSets []*EpochValidatorSet `protobuf:"bytes,5,rep,name=slashed_validator_sets,json=slashedValidatorSets,proto3" json:"slashed_validator_sets,omitempty"`
	// validators_lifecycle contains the lifecyle of all validators
	ValidatorsLifecycle []*ValidatorLifecycle `protobuf:"bytes,6,rep,name=validators_lifecycle,json=validatorsLifecycle,proto3" json:"validators_lifecycle,omitempty"`
	// delegations_lifecycle contains the lifecyle of all delegations
	DelegationsLifecycle []*DelegationLifecycle `protobuf:"bytes,7,rep,name=delegations_lifecycle,json=delegationsLifecycle,proto3" json:"delegations_lifecycle,omitempty"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ef836361c424501, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetEpochs() []*Epoch {
	if m != nil {
		return m.Epochs
	}
	return nil
}

func (m *GenesisState) GetQueues() []*EpochQueue {
	if m != nil {
		return m.Queues
	}
	return nil
}

func (m *GenesisState) GetValidatorSets() []*EpochValidatorSet {
	if m != nil {
		return m.ValidatorSets
	}
	return nil
}

func (m *GenesisState) GetSlashedValidatorSets() []*EpochValidatorSet {
	if m != nil {
		return m.SlashedValidatorSets
	}
	return nil
}

func (m *GenesisState) GetValidatorsLifecycle() []*ValidatorLifecycle {
	if m != nil {
		return m.ValidatorsLifecycle
	}
	return nil
}

func (m *GenesisState) GetDelegationsLifecycle() []*DelegationLifecycle {
	if m != nil {
		return m.DelegationsLifecycle
	}
	return nil
}

// EpochQueue defines a genesis state entry for
// the epochs' message queue
type EpochQueue struct {
	// epoch_number is the epoch's identifier
	EpochNumber uint64 `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
	// msgs is a slice containing all the epochs' queued messages
	Msgs []*QueuedMessage `protobuf:"bytes,2,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *EpochQueue) Reset()         { *m = EpochQueue{} }
func (m *EpochQueue) String() string { return proto.CompactTextString(m) }
func (*EpochQueue) ProtoMessage()    {}
func (*EpochQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ef836361c424501, []int{1}
}
func (m *EpochQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochQueue.Merge(m, src)
}
func (m *EpochQueue) XXX_Size() int {
	return m.Size()
}
func (m *EpochQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochQueue.DiscardUnknown(m)
}

var xxx_messageInfo_EpochQueue proto.InternalMessageInfo

func (m *EpochQueue) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *EpochQueue) GetMsgs() []*QueuedMessage {
	if m != nil {
		return m.Msgs
	}
	return nil
}

// EpochValidatorSet contains the epoch number and the validators corresponding
// to that epoch number
type EpochValidatorSet struct {
	// epoch_number is the epoch's identifier
	EpochNumber uint64 `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
	// validators is a slice containing the validators of the
	// epoch's validator set
	Validators []*Validator `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators,omitempty"`
}

func (m *EpochValidatorSet) Reset()         { *m = EpochValidatorSet{} }
func (m *EpochValidatorSet) String() string { return proto.CompactTextString(m) }
func (*EpochValidatorSet) ProtoMessage()    {}
func (*EpochValidatorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ef836361c424501, []int{2}
}
func (m *EpochValidatorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochValidatorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochValidatorSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochValidatorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochValidatorSet.Merge(m, src)
}
func (m *EpochValidatorSet) XXX_Size() int {
	return m.Size()
}
func (m *EpochValidatorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochValidatorSet.DiscardUnknown(m)
}

var xxx_messageInfo_EpochValidatorSet proto.InternalMessageInfo

func (m *EpochValidatorSet) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *EpochValidatorSet) GetValidators() []*Validator {
	if m != nil {
		return m.Validators
	}
	return nil
}

func init() {
	proto.RegisterType((*GenesisState)(nil), "babylon.epoching.v1.GenesisState")
	proto.RegisterType((*EpochQueue)(nil), "babylon.epoching.v1.EpochQueue")
	proto.RegisterType((*EpochValidatorSet)(nil), "babylon.epoching.v1.EpochValidatorSet")
}

func init() { proto.RegisterFile("babylon/epoching/v1/genesis.proto", fileDescriptor_2ef836361c424501) }

var fileDescriptor_2ef836361c424501 = []byte{
	// 454 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0x4d, 0x6f, 0xd3, 0x30,
	0x18, 0xc7, 0x1b, 0x16, 0x82, 0xf4, 0x74, 0x20, 0xe1, 0x15, 0x14, 0x15, 0x29, 0xeb, 0x72, 0x80,
	0x5e, 0x48, 0xb4, 0x4e, 0x80, 0xb8, 0x70, 0x98, 0x40, 0x5c, 0x18, 0x2f, 0x9e, 0xb4, 0xc3, 0x04,
	0xaa, 0x9c, 0xf6, 0xc1, 0x8d, 0x94, 0xc6, 0x25, 0x76, 0x22, 0xfa, 0x2d, 0xf8, 0x04, 0x7c, 0x9e,
	0x1d, 0x77, 0xe4, 0x84, 0x50, 0xfb, 0x45, 0x50, 0x5d, 0xe7, 0x05, 0xc8, 0x10, 0xdc, 0xec, 0xc7,
	0xbf, 0xff, 0xef, 0xb1, 0x1e, 0xd9, 0x70, 0x10, 0xb1, 0x68, 0x99, 0x88, 0x34, 0xc4, 0x85, 0x98,
	0xcc, 0xe2, 0x94, 0x87, 0xc5, 0x61, 0xc8, 0x31, 0x45, 0x19, 0xcb, 0x60, 0x91, 0x09, 0x25, 0xc8,
	0x9e, 0x41, 0x82, 0x12, 0x09, 0x8a, 0xc3, 0x7e, 0x8f, 0x0b, 0x2e, 0xf4, 0x79, 0xb8, 0x59, 0x6d,
	0xd1, 0xfe, 0xa0, 0xcd, 0xb6, 0x60, 0x19, 0x9b, 0x1b, 0x59, 0xdf, 0x6f, 0x23, 0x2a, 0xb1, 0x66,
	0xfc, 0xaf, 0x36, 0xec, 0xbe, 0xdc, 0x5e, 0xe1, 0x54, 0x31, 0x85, 0xe4, 0x29, 0x38, 0x5b, 0x89,
	0x6b, 0x0d, 0xac, 0x61, 0x77, 0x74, 0x2f, 0x68, 0xb9, 0x52, 0xf0, 0x56, 0x23, 0xc7, 0xf6, 0xc5,
	0xf7, 0xfd, 0x0e, 0x35, 0x01, 0x32, 0x02, 0x47, 0x33, 0xd2, 0xbd, 0x36, 0xd8, 0x19, 0x76, 0x47,
	0xfd, 0xd6, 0xe8, 0x8b, 0xcd, 0x9a, 0x1a, 0x92, 0x3c, 0x01, 0xe7, 0x53, 0x8e, 0x39, 0x4a, 0x77,
	0x47, 0x67, 0xf6, 0xaf, 0xce, 0xbc, 0xdb, 0x70, 0xd4, 0xe0, 0xe4, 0x04, 0x6e, 0x15, 0x2c, 0x89,
	0xa7, 0x4c, 0x89, 0x6c, 0x2c, 0x51, 0x49, 0xd7, 0xd6, 0x82, 0xfb, 0x57, 0x0b, 0xce, 0x4a, 0xfe,
	0x14, 0x15, 0xbd, 0x59, 0x34, 0x76, 0x92, 0xbc, 0x87, 0xbb, 0x32, 0x61, 0x72, 0x86, 0xd3, 0xf1,
	0x6f, 0xda, 0xeb, 0xff, 0xa5, 0xed, 0x19, 0xcb, 0xd9, 0x2f, 0xf6, 0x73, 0xe8, 0x55, 0x56, 0x39,
	0x4e, 0xe2, 0x8f, 0x38, 0x59, 0x4e, 0x12, 0x74, 0x1d, 0xed, 0x7e, 0xd0, 0xea, 0xae, 0x0c, 0xaf,
	0x4a, 0x9c, 0xee, 0xd5, 0x92, 0xaa, 0x48, 0x3e, 0xc0, 0x9d, 0x29, 0x26, 0xc8, 0x99, 0x8a, 0x45,
	0xda, 0x94, 0xdf, 0xd0, 0xf2, 0x61, 0xab, 0xfc, 0x79, 0x95, 0xa8, 0xed, 0xbd, 0x86, 0xa6, 0xaa,
	0xfa, 0x1c, 0xa0, 0x9e, 0x3e, 0x39, 0x80, 0x5d, 0xad, 0x19, 0xa7, 0xf9, 0x3c, 0xc2, 0x4c, 0xbf,
	0x11, 0x9b, 0x76, 0x75, 0xed, 0xb5, 0x2e, 0x91, 0xc7, 0x60, 0xcf, 0x25, 0x2f, 0xdf, 0x80, 0xdf,
	0xda, 0x5e, 0xcb, 0xa6, 0x27, 0x28, 0x25, 0xe3, 0x48, 0x35, 0xef, 0x17, 0x70, 0xfb, 0x8f, 0x71,
	0xfe, 0x4b, 0xbf, 0x67, 0x00, 0xf5, 0x58, 0x4c, 0x57, 0xef, 0xef, 0x13, 0xa5, 0x8d, 0xc4, 0xf1,
	0x9b, 0x8b, 0x95, 0x67, 0x5d, 0xae, 0x3c, 0xeb, 0xc7, 0xca, 0xb3, 0xbe, 0xac, 0xbd, 0xce, 0xe5,
	0xda, 0xeb, 0x7c, 0x5b, 0x7b, 0x9d, 0xf3, 0x47, 0x3c, 0x56, 0xb3, 0x3c, 0x0a, 0x26, 0x62, 0x1e,
	0x1a, 0x5f, 0xc2, 0x22, 0xf9, 0x30, 0x16, 0xe5, 0x36, 0x2c, 0x8e, 0xc2, 0xcf, 0xf5, 0xf7, 0x52,
	0xcb, 0x05, 0xca, 0xc8, 0xd1, 0x3f, 0xeb, 0xe8, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf1, 0x40,
	0x5d, 0x61, 0xef, 0x03, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegationsLifecycle) > 0 {
		for iNdEx := len(m.DelegationsLifecycle) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DelegationsLifecycle[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ValidatorsLifecycle) > 0 {
		for iNdEx := len(m.ValidatorsLifecycle) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorsLifecycle[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SlashedValidatorSets) > 0 {
		for iNdEx := len(m.SlashedValidatorSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashedValidatorSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ValidatorSets) > 0 {
		for iNdEx := len(m.ValidatorSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Queues) > 0 {
		for iNdEx := len(m.Queues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Queues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Epochs) > 0 {
		for iNdEx := len(m.Epochs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Epochs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EpochQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EpochNumber != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochValidatorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochValidatorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochValidatorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EpochNumber != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.Epochs) > 0 {
		for _, e := range m.Epochs {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.ValidatorSets) > 0 {
		for _, e := range m.ValidatorSets {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.SlashedValidatorSets) > 0 {
		for _, e := range m.SlashedValidatorSets {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.ValidatorsLifecycle) > 0 {
		for _, e := range m.ValidatorsLifecycle {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.DelegationsLifecycle) > 0 {
		for _, e := range m.DelegationsLifecycle {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *EpochQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovGenesis(uint64(m.EpochNumber))
	}
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *EpochValidatorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovGenesis(uint64(m.EpochNumber))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epochs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Epochs = append(m.Epochs, &Epoch{})
			if err := m.Epochs[len(m.Epochs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &EpochQueue{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorSets = append(m.ValidatorSets, &EpochValidatorSet{})
			if err := m.ValidatorSets[len(m.ValidatorSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedValidatorSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashedValidatorSets = append(m.SlashedValidatorSets, &EpochValidatorSet{})
			if err := m.SlashedValidatorSets[len(m.SlashedValidatorSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorsLifecycle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorsLifecycle = append(m.ValidatorsLifecycle, &ValidatorLifecycle{})
			if err := m.ValidatorsLifecycle[len(m.ValidatorsLifecycle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationsLifecycle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegationsLifecycle = append(m.DelegationsLifecycle, &DelegationLifecycle{})
			if err := m.DelegationsLifecycle[len(m.DelegationsLifecycle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &QueuedMessage{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochValidatorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochValidatorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochValidatorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &Validator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
