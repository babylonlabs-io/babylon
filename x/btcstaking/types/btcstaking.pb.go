// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/btcstaking/v1/btcstaking.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_babylonlabs_io_babylon_types "github.com/babylonlabs-io/babylon/types"
	types1 "github.com/babylonlabs-io/babylon/x/btccheckpoint/types"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/x/staking/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BTCDelegationStatus is the status of a delegation.
// There are two possible valid state transition paths for a BTC delegation:
// - PENDING -> VERIFIED -> ACTIVE -> UNBONDED -> EXPIRED
// - PENDING -> VERIFIED -> ACTIVE -> UNBONDED/EXPIRED
// and one invalid state transition path:
// - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
// activating delegation on Babylon chain.
// In valid transition paths, the delegation becomes UNBONDED when:
// - either the staking transaction timelock expires
// - or the staker requests early undelegation through MsgBTCUndelegate message.
type BTCDelegationStatus int32

const (
	// PENDING defines a delegation that is waiting for covenant signatures.
	BTCDelegationStatus_PENDING BTCDelegationStatus = 0
	// VERIFIED defines a delegation that has covenant signatures but is not yet
	// included in the BTC chain.
	BTCDelegationStatus_VERIFIED BTCDelegationStatus = 1
	// ACTIVE defines a delegation that has voting power
	BTCDelegationStatus_ACTIVE BTCDelegationStatus = 2
	// UNBONDED defines a delegation no longer has voting power
	// by receiving unbonding tx with signatures from staker and covenant committee
	BTCDelegationStatus_UNBONDED BTCDelegationStatus = 3
	// EXPIRED defines a delegation no longer has voting power
	// for reaching the end of staking transaction timelock
	BTCDelegationStatus_EXPIRED BTCDelegationStatus = 4
	// ANY is any of the above status
	BTCDelegationStatus_ANY BTCDelegationStatus = 5
)

var BTCDelegationStatus_name = map[int32]string{
	0: "PENDING",
	1: "VERIFIED",
	2: "ACTIVE",
	3: "UNBONDED",
	4: "EXPIRED",
	5: "ANY",
}

var BTCDelegationStatus_value = map[string]int32{
	"PENDING":  0,
	"VERIFIED": 1,
	"ACTIVE":   2,
	"UNBONDED": 3,
	"EXPIRED":  4,
	"ANY":      5,
}

func (x BTCDelegationStatus) String() string {
	return proto.EnumName(BTCDelegationStatus_name, int32(x))
}

func (BTCDelegationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}

// FinalityProvider defines a finality provider
type FinalityProvider struct {
	// addr is the bech32 address identifier of the finality provider.
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// description defines the description terms for the finality provider.
	Description *types.Description `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// commission defines the commission rate of the finality provider.
	Commission *cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=commission,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"commission,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this finality provider
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonlabs_io_babylon_types.BIP340PubKey `protobuf:"bytes,4,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of the btc_pk, where the BTC
	// private key signs the bech32 bbn addr of the finality provider.
	Pop *ProofOfPossessionBTC `protobuf:"bytes,5,opt,name=pop,proto3" json:"pop,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,6,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBtcHeight uint32 `protobuf:"varint,7,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
	// jailed defines whether the finality provider is jailed
	Jailed bool `protobuf:"varint,8,opt,name=jailed,proto3" json:"jailed,omitempty"`
	// highest_voted_height is the highest height for which the
	// finality provider has voted
	HighestVotedHeight uint32 `protobuf:"varint,9,opt,name=highest_voted_height,json=highestVotedHeight,proto3" json:"highest_voted_height,omitempty"`
	// consumer_id is the ID of the consumer the finality provider is operating on.
	// If it's missing / empty, it's assumed the finality provider is operating in the Babylon chain.
	ConsumerId string `protobuf:"bytes,10,opt,name=consumer_id,json=consumerId,proto3" json:"consumer_id,omitempty"`
}

func (m *FinalityProvider) Reset()         { *m = FinalityProvider{} }
func (m *FinalityProvider) String() string { return proto.CompactTextString(m) }
func (*FinalityProvider) ProtoMessage()    {}
func (*FinalityProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}
func (m *FinalityProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalityProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalityProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalityProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalityProvider.Merge(m, src)
}
func (m *FinalityProvider) XXX_Size() int {
	return m.Size()
}
func (m *FinalityProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalityProvider.DiscardUnknown(m)
}

var xxx_messageInfo_FinalityProvider proto.InternalMessageInfo

func (m *FinalityProvider) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *FinalityProvider) GetDescription() *types.Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *FinalityProvider) GetPop() *ProofOfPossessionBTC {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *FinalityProvider) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *FinalityProvider) GetSlashedBtcHeight() uint32 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

func (m *FinalityProvider) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *FinalityProvider) GetHighestVotedHeight() uint32 {
	if m != nil {
		return m.HighestVotedHeight
	}
	return 0
}

func (m *FinalityProvider) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

// FinalityProviderWithMeta wraps the FinalityProvider with metadata.
type FinalityProviderWithMeta struct {
	// btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonlabs_io_babylon_types.BIP340PubKey `protobuf:"bytes,1,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// height is the queried Babylon height
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// voting_power is the voting power of this finality provider at the given height
	VotingPower uint64 `protobuf:"varint,3,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,4,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBtcHeight uint32 `protobuf:"varint,5,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
	// jailed defines whether the finality provider is detected jailed
	Jailed bool `protobuf:"varint,6,opt,name=jailed,proto3" json:"jailed,omitempty"`
	// highest_voted_height is the highest height for which the
	// finality provider has voted
	HighestVotedHeight uint32 `protobuf:"varint,7,opt,name=highest_voted_height,json=highestVotedHeight,proto3" json:"highest_voted_height,omitempty"`
}

func (m *FinalityProviderWithMeta) Reset()         { *m = FinalityProviderWithMeta{} }
func (m *FinalityProviderWithMeta) String() string { return proto.CompactTextString(m) }
func (*FinalityProviderWithMeta) ProtoMessage()    {}
func (*FinalityProviderWithMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{1}
}
func (m *FinalityProviderWithMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalityProviderWithMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalityProviderWithMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalityProviderWithMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalityProviderWithMeta.Merge(m, src)
}
func (m *FinalityProviderWithMeta) XXX_Size() int {
	return m.Size()
}
func (m *FinalityProviderWithMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalityProviderWithMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FinalityProviderWithMeta proto.InternalMessageInfo

func (m *FinalityProviderWithMeta) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetSlashedBtcHeight() uint32 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *FinalityProviderWithMeta) GetHighestVotedHeight() uint32 {
	if m != nil {
		return m.HighestVotedHeight
	}
	return 0
}

// BTCDelegation defines a BTC delegation
type BTCDelegation struct {
	// staker_addr is the address to receive rewards from BTC delegation.
	StakerAddr string `protobuf:"bytes,1,opt,name=staker_addr,json=stakerAddr,proto3" json:"staker_addr,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonlabs_io_babylon_types.BIP340PubKey `protobuf:"bytes,2,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossessionBTC `protobuf:"bytes,3,opt,name=pop,proto3" json:"pop,omitempty"`
	// fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
	// this BTC delegation delegates to
	// If there is more than 1 PKs, then this means the delegation is restaked
	// to multiple finality providers
	FpBtcPkList []github_com_babylonlabs_io_babylon_types.BIP340PubKey `protobuf:"bytes,4,rep,name=fp_btc_pk_list,json=fpBtcPkList,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"fp_btc_pk_list,omitempty"`
	// staking_time is the number of blocks for which the delegation is locked on BTC chain
	StakingTime uint32 `protobuf:"varint,5,opt,name=staking_time,json=stakingTime,proto3" json:"staking_time,omitempty"`
	// start_height is the start BTC height of the BTC delegation
	// it is the start BTC height of the timelock
	StartHeight uint32 `protobuf:"varint,6,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is the end height of the BTC delegation
	// it is calculated by end_height = start_height + staking_time
	EndHeight uint32 `protobuf:"varint,7,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// total_sat is the total amount of BTC stakes in this delegation
	// quantified in satoshi
	TotalSat uint64 `protobuf:"varint,8,opt,name=total_sat,json=totalSat,proto3" json:"total_sat,omitempty"`
	// staking_tx is the staking tx
	StakingTx []byte `protobuf:"bytes,9,opt,name=staking_tx,json=stakingTx,proto3" json:"staking_tx,omitempty"`
	// staking_output_idx is the index of the staking output in the staking tx
	StakingOutputIdx uint32 `protobuf:"varint,10,opt,name=staking_output_idx,json=stakingOutputIdx,proto3" json:"staking_output_idx,omitempty"`
	// slashing_tx is the slashing tx
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// finality provider or covenant yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,11,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the staking tx output.
	DelegatorSig *github_com_babylonlabs_io_babylon_types.BIP340Signature `protobuf:"bytes,12,opt,name=delegator_sig,json=delegatorSig,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340Signature" json:"delegator_sig,omitempty"`
	// covenant_sigs is a list of adaptor signatures on the slashing tx
	// by each covenant member
	// It will be a part of the witness for the staking tx output.
	CovenantSigs []*CovenantAdaptorSignatures `protobuf:"bytes,13,rep,name=covenant_sigs,json=covenantSigs,proto3" json:"covenant_sigs,omitempty"`
	// unbonding_time describes how long the funds will be locked either in unbonding output
	// or slashing change output
	UnbondingTime uint32 `protobuf:"varint,14,opt,name=unbonding_time,json=unbondingTime,proto3" json:"unbonding_time,omitempty"`
	// btc_undelegation is the information about the early unbonding path of the BTC delegation
	BtcUndelegation *BTCUndelegation `protobuf:"bytes,15,opt,name=btc_undelegation,json=btcUndelegation,proto3" json:"btc_undelegation,omitempty"`
	// version of the params used to validate the delegation
	ParamsVersion uint32 `protobuf:"varint,16,opt,name=params_version,json=paramsVersion,proto3" json:"params_version,omitempty"`
	// btc_tip_height is the height of the BTC light client tip at the time of
	// the delegation creation
	BtcTipHeight uint32 `protobuf:"varint,17,opt,name=btc_tip_height,json=btcTipHeight,proto3" json:"btc_tip_height,omitempty"`
}

func (m *BTCDelegation) Reset()         { *m = BTCDelegation{} }
func (m *BTCDelegation) String() string { return proto.CompactTextString(m) }
func (*BTCDelegation) ProtoMessage()    {}
func (*BTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{2}
}
func (m *BTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegation.Merge(m, src)
}
func (m *BTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegation proto.InternalMessageInfo

func (m *BTCDelegation) GetStakerAddr() string {
	if m != nil {
		return m.StakerAddr
	}
	return ""
}

func (m *BTCDelegation) GetPop() *ProofOfPossessionBTC {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCDelegation) GetStakingTime() uint32 {
	if m != nil {
		return m.StakingTime
	}
	return 0
}

func (m *BTCDelegation) GetStartHeight() uint32 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *BTCDelegation) GetEndHeight() uint32 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *BTCDelegation) GetTotalSat() uint64 {
	if m != nil {
		return m.TotalSat
	}
	return 0
}

func (m *BTCDelegation) GetStakingTx() []byte {
	if m != nil {
		return m.StakingTx
	}
	return nil
}

func (m *BTCDelegation) GetStakingOutputIdx() uint32 {
	if m != nil {
		return m.StakingOutputIdx
	}
	return 0
}

func (m *BTCDelegation) GetCovenantSigs() []*CovenantAdaptorSignatures {
	if m != nil {
		return m.CovenantSigs
	}
	return nil
}

func (m *BTCDelegation) GetUnbondingTime() uint32 {
	if m != nil {
		return m.UnbondingTime
	}
	return 0
}

func (m *BTCDelegation) GetBtcUndelegation() *BTCUndelegation {
	if m != nil {
		return m.BtcUndelegation
	}
	return nil
}

func (m *BTCDelegation) GetParamsVersion() uint32 {
	if m != nil {
		return m.ParamsVersion
	}
	return 0
}

func (m *BTCDelegation) GetBtcTipHeight() uint32 {
	if m != nil {
		return m.BtcTipHeight
	}
	return 0
}

// DelegatorUnbondingInfo contains the information about transaction which spent
// the staking output. It contains:
// - spend_stake_tx: the transaction which spent the staking output
type DelegatorUnbondingInfo struct {
	// spend_stake_tx is the transaction which spent the staking output. It is
	// filled only if spend_stake_tx is different than unbonding_tx registered
	// on the Babylon chain.
	SpendStakeTx []byte `protobuf:"bytes,1,opt,name=spend_stake_tx,json=spendStakeTx,proto3" json:"spend_stake_tx,omitempty"`
}

func (m *DelegatorUnbondingInfo) Reset()         { *m = DelegatorUnbondingInfo{} }
func (m *DelegatorUnbondingInfo) String() string { return proto.CompactTextString(m) }
func (*DelegatorUnbondingInfo) ProtoMessage()    {}
func (*DelegatorUnbondingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{3}
}
func (m *DelegatorUnbondingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorUnbondingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorUnbondingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorUnbondingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorUnbondingInfo.Merge(m, src)
}
func (m *DelegatorUnbondingInfo) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorUnbondingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorUnbondingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorUnbondingInfo proto.InternalMessageInfo

func (m *DelegatorUnbondingInfo) GetSpendStakeTx() []byte {
	if m != nil {
		return m.SpendStakeTx
	}
	return nil
}

// BTCUndelegation contains the information about the early unbonding path of the BTC delegation
type BTCUndelegation struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower timelock
	// than staking output.
	UnbondingTx []byte `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// slashing_tx is the slashing tx for unbonding transactions
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// finality provider or covenant yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,2,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_slashing_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the unbonding tx output.
	DelegatorSlashingSig *github_com_babylonlabs_io_babylon_types.BIP340Signature `protobuf:"bytes,3,opt,name=delegator_slashing_sig,json=delegatorSlashingSig,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340Signature" json:"delegator_slashing_sig,omitempty"`
	// covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
	// by each covenant member
	// It will be a part of the witness for the staking tx output.
	CovenantSlashingSigs []*CovenantAdaptorSignatures `protobuf:"bytes,4,rep,name=covenant_slashing_sigs,json=covenantSlashingSigs,proto3" json:"covenant_slashing_sigs,omitempty"`
	// covenant_unbonding_sig_list is the list of signatures on the unbonding tx
	// by covenant members
	// It must be provided after processing undelegate message by Babylon
	CovenantUnbondingSigList []*SignatureInfo `protobuf:"bytes,5,rep,name=covenant_unbonding_sig_list,json=covenantUnbondingSigList,proto3" json:"covenant_unbonding_sig_list,omitempty"`
	// delegator_unbonding_info is the information about transaction which spent
	// the staking output
	DelegatorUnbondingInfo *DelegatorUnbondingInfo `protobuf:"bytes,6,opt,name=delegator_unbonding_info,json=delegatorUnbondingInfo,proto3" json:"delegator_unbonding_info,omitempty"`
}

func (m *BTCUndelegation) Reset()         { *m = BTCUndelegation{} }
func (m *BTCUndelegation) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegation) ProtoMessage()    {}
func (*BTCUndelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{4}
}
func (m *BTCUndelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegation.Merge(m, src)
}
func (m *BTCUndelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegation proto.InternalMessageInfo

func (m *BTCUndelegation) GetUnbondingTx() []byte {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

func (m *BTCUndelegation) GetCovenantSlashingSigs() []*CovenantAdaptorSignatures {
	if m != nil {
		return m.CovenantSlashingSigs
	}
	return nil
}

func (m *BTCUndelegation) GetCovenantUnbondingSigList() []*SignatureInfo {
	if m != nil {
		return m.CovenantUnbondingSigList
	}
	return nil
}

func (m *BTCUndelegation) GetDelegatorUnbondingInfo() *DelegatorUnbondingInfo {
	if m != nil {
		return m.DelegatorUnbondingInfo
	}
	return nil
}

// BTCDelegatorDelegations is a collection of BTC delegations from the same delegator.
type BTCDelegatorDelegations struct {
	Dels []*BTCDelegation `protobuf:"bytes,1,rep,name=dels,proto3" json:"dels,omitempty"`
}

func (m *BTCDelegatorDelegations) Reset()         { *m = BTCDelegatorDelegations{} }
func (m *BTCDelegatorDelegations) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegations) ProtoMessage()    {}
func (*BTCDelegatorDelegations) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{5}
}
func (m *BTCDelegatorDelegations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegations.Merge(m, src)
}
func (m *BTCDelegatorDelegations) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegations) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegations.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegations proto.InternalMessageInfo

func (m *BTCDelegatorDelegations) GetDels() []*BTCDelegation {
	if m != nil {
		return m.Dels
	}
	return nil
}

// BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations from the same delegator.
type BTCDelegatorDelegationIndex struct {
	StakingTxHashList [][]byte `protobuf:"bytes,1,rep,name=staking_tx_hash_list,json=stakingTxHashList,proto3" json:"staking_tx_hash_list,omitempty"`
}

func (m *BTCDelegatorDelegationIndex) Reset()         { *m = BTCDelegatorDelegationIndex{} }
func (m *BTCDelegatorDelegationIndex) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegationIndex) ProtoMessage()    {}
func (*BTCDelegatorDelegationIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{6}
}
func (m *BTCDelegatorDelegationIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegationIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegationIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegationIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegationIndex.Merge(m, src)
}
func (m *BTCDelegatorDelegationIndex) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegationIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegationIndex.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegationIndex proto.InternalMessageInfo

func (m *BTCDelegatorDelegationIndex) GetStakingTxHashList() [][]byte {
	if m != nil {
		return m.StakingTxHashList
	}
	return nil
}

// SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK
type SignatureInfo struct {
	Pk  *github_com_babylonlabs_io_babylon_types.BIP340PubKey    `protobuf:"bytes,1,opt,name=pk,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"pk,omitempty"`
	Sig *github_com_babylonlabs_io_babylon_types.BIP340Signature `protobuf:"bytes,2,opt,name=sig,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340Signature" json:"sig,omitempty"`
}

func (m *SignatureInfo) Reset()         { *m = SignatureInfo{} }
func (m *SignatureInfo) String() string { return proto.CompactTextString(m) }
func (*SignatureInfo) ProtoMessage()    {}
func (*SignatureInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{7}
}
func (m *SignatureInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureInfo.Merge(m, src)
}
func (m *SignatureInfo) XXX_Size() int {
	return m.Size()
}
func (m *SignatureInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureInfo proto.InternalMessageInfo

// CovenantAdaptorSignatures is a list adaptor signatures signed by the
// covenant with different finality provider's public keys as encryption keys
type CovenantAdaptorSignatures struct {
	// cov_pk is the public key of the covenant emulator, used as the public key of the adaptor signature
	CovPk *github_com_babylonlabs_io_babylon_types.BIP340PubKey `protobuf:"bytes,1,opt,name=cov_pk,json=covPk,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"cov_pk,omitempty"`
	// adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked BTC finality provider's public key
	AdaptorSigs [][]byte `protobuf:"bytes,2,rep,name=adaptor_sigs,json=adaptorSigs,proto3" json:"adaptor_sigs,omitempty"`
}

func (m *CovenantAdaptorSignatures) Reset()         { *m = CovenantAdaptorSignatures{} }
func (m *CovenantAdaptorSignatures) String() string { return proto.CompactTextString(m) }
func (*CovenantAdaptorSignatures) ProtoMessage()    {}
func (*CovenantAdaptorSignatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{8}
}
func (m *CovenantAdaptorSignatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CovenantAdaptorSignatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CovenantAdaptorSignatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CovenantAdaptorSignatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CovenantAdaptorSignatures.Merge(m, src)
}
func (m *CovenantAdaptorSignatures) XXX_Size() int {
	return m.Size()
}
func (m *CovenantAdaptorSignatures) XXX_DiscardUnknown() {
	xxx_messageInfo_CovenantAdaptorSignatures.DiscardUnknown(m)
}

var xxx_messageInfo_CovenantAdaptorSignatures proto.InternalMessageInfo

func (m *CovenantAdaptorSignatures) GetAdaptorSigs() [][]byte {
	if m != nil {
		return m.AdaptorSigs
	}
	return nil
}

// SelectiveSlashingEvidence is the evidence that the finality provider
// selectively slashed a BTC delegation
// NOTE: it's possible that a slashed finality provider exploits the
// SelectiveSlashingEvidence endpoint while it is actually slashed due to
// equivocation. But such behaviour does not affect the system's security
// or gives any benefit for the adversary
type SelectiveSlashingEvidence struct {
	// staking_tx_hash is the hash of the staking tx.
	// It uniquely identifies a BTC delegation
	StakingTxHash string `protobuf:"bytes,1,opt,name=staking_tx_hash,json=stakingTxHash,proto3" json:"staking_tx_hash,omitempty"`
	// fp_btc_pk is the BTC PK of the finality provider who
	// launches the selective slashing offence
	FpBtcPk *github_com_babylonlabs_io_babylon_types.BIP340PubKey `protobuf:"bytes,2,opt,name=fp_btc_pk,json=fpBtcPk,proto3,customtype=github.com/babylonlabs-io/babylon/types.BIP340PubKey" json:"fp_btc_pk,omitempty"`
	// recovered_fp_btc_sk is the finality provider's BTC SK recovered from
	// the covenant adaptor/Schnorr signature pair. It is the consequence
	// of selective slashing.
	RecoveredFpBtcSk []byte `protobuf:"bytes,3,opt,name=recovered_fp_btc_sk,json=recoveredFpBtcSk,proto3" json:"recovered_fp_btc_sk,omitempty"`
}

func (m *SelectiveSlashingEvidence) Reset()         { *m = SelectiveSlashingEvidence{} }
func (m *SelectiveSlashingEvidence) String() string { return proto.CompactTextString(m) }
func (*SelectiveSlashingEvidence) ProtoMessage()    {}
func (*SelectiveSlashingEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{9}
}
func (m *SelectiveSlashingEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SelectiveSlashingEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SelectiveSlashingEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SelectiveSlashingEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SelectiveSlashingEvidence.Merge(m, src)
}
func (m *SelectiveSlashingEvidence) XXX_Size() int {
	return m.Size()
}
func (m *SelectiveSlashingEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_SelectiveSlashingEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_SelectiveSlashingEvidence proto.InternalMessageInfo

func (m *SelectiveSlashingEvidence) GetStakingTxHash() string {
	if m != nil {
		return m.StakingTxHash
	}
	return ""
}

func (m *SelectiveSlashingEvidence) GetRecoveredFpBtcSk() []byte {
	if m != nil {
		return m.RecoveredFpBtcSk
	}
	return nil
}

// InclusionProof proves the existence of tx on BTC blockchain
// including
// - the position of the tx on BTC blockchain
// - the Merkle proof that this tx is on the above position
type InclusionProof struct {
	// key is the position (txIdx, blockHash) of this tx on BTC blockchain
	Key *types1.TransactionKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// proof is the Merkle proof that this tx is included in the position in `key`
	Proof []byte `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *InclusionProof) Reset()         { *m = InclusionProof{} }
func (m *InclusionProof) String() string { return proto.CompactTextString(m) }
func (*InclusionProof) ProtoMessage()    {}
func (*InclusionProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{10}
}
func (m *InclusionProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InclusionProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InclusionProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InclusionProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InclusionProof.Merge(m, src)
}
func (m *InclusionProof) XXX_Size() int {
	return m.Size()
}
func (m *InclusionProof) XXX_DiscardUnknown() {
	xxx_messageInfo_InclusionProof.DiscardUnknown(m)
}

var xxx_messageInfo_InclusionProof proto.InternalMessageInfo

func (m *InclusionProof) GetKey() *types1.TransactionKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *InclusionProof) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

func init() {
	proto.RegisterEnum("babylon.btcstaking.v1.BTCDelegationStatus", BTCDelegationStatus_name, BTCDelegationStatus_value)
	proto.RegisterType((*FinalityProvider)(nil), "babylon.btcstaking.v1.FinalityProvider")
	proto.RegisterType((*FinalityProviderWithMeta)(nil), "babylon.btcstaking.v1.FinalityProviderWithMeta")
	proto.RegisterType((*BTCDelegation)(nil), "babylon.btcstaking.v1.BTCDelegation")
	proto.RegisterType((*DelegatorUnbondingInfo)(nil), "babylon.btcstaking.v1.DelegatorUnbondingInfo")
	proto.RegisterType((*BTCUndelegation)(nil), "babylon.btcstaking.v1.BTCUndelegation")
	proto.RegisterType((*BTCDelegatorDelegations)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegations")
	proto.RegisterType((*BTCDelegatorDelegationIndex)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegationIndex")
	proto.RegisterType((*SignatureInfo)(nil), "babylon.btcstaking.v1.SignatureInfo")
	proto.RegisterType((*CovenantAdaptorSignatures)(nil), "babylon.btcstaking.v1.CovenantAdaptorSignatures")
	proto.RegisterType((*SelectiveSlashingEvidence)(nil), "babylon.btcstaking.v1.SelectiveSlashingEvidence")
	proto.RegisterType((*InclusionProof)(nil), "babylon.btcstaking.v1.InclusionProof")
}

func init() {
	proto.RegisterFile("babylon/btcstaking/v1/btcstaking.proto", fileDescriptor_3851ae95ccfaf7db)
}

var fileDescriptor_3851ae95ccfaf7db = []byte{
	// 1416 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x6e, 0xdb, 0x46,
	0x16, 0x36, 0x25, 0xf9, 0xef, 0x50, 0xb2, 0x95, 0x89, 0xd6, 0xcb, 0xc4, 0x58, 0xdb, 0xab, 0xcd,
	0x06, 0x42, 0x1b, 0x4b, 0xb1, 0x13, 0xa0, 0x69, 0x8b, 0x16, 0xb0, 0x2c, 0xa5, 0x11, 0x9a, 0xd8,
	0x2a, 0x25, 0xbb, 0x3f, 0x40, 0xc1, 0x50, 0xe4, 0x98, 0x9a, 0x4a, 0xe2, 0xb0, 0x9c, 0x91, 0x2a,
	0x3f, 0x45, 0xdb, 0xb7, 0xe8, 0x03, 0xa4, 0x77, 0x7d, 0x80, 0x5c, 0x06, 0x41, 0x2f, 0x0a, 0x5f,
	0x18, 0x45, 0xf2, 0x22, 0xc5, 0x0c, 0x29, 0x92, 0x76, 0xed, 0xd4, 0x89, 0x7d, 0xc7, 0x39, 0xff,
	0xfc, 0xce, 0x77, 0xe6, 0x90, 0x70, 0xbb, 0x63, 0x76, 0x0e, 0xfb, 0xd4, 0xad, 0x74, 0xb8, 0xc5,
	0xb8, 0xd9, 0x23, 0xae, 0x53, 0x19, 0x6d, 0x24, 0x4e, 0x65, 0xcf, 0xa7, 0x9c, 0xa2, 0x7f, 0x85,
	0x76, 0xe5, 0x84, 0x66, 0xb4, 0x71, 0xb3, 0xe0, 0x50, 0x87, 0x4a, 0x8b, 0x8a, 0x78, 0x0a, 0x8c,
	0x6f, 0xde, 0xb0, 0x28, 0x1b, 0x50, 0x66, 0x04, 0x8a, 0xe0, 0x10, 0xaa, 0x6e, 0x05, 0xa7, 0x4a,
	0x9c, 0xab, 0x83, 0xb9, 0xb9, 0x51, 0x39, 0x91, 0xed, 0xe6, 0xea, 0xd9, 0x55, 0x79, 0xd4, 0x0b,
	0x0d, 0xee, 0x24, 0x0c, 0xac, 0x2e, 0xb6, 0x7a, 0x1e, 0x25, 0x2e, 0x0f, 0x2b, 0x8f, 0x05, 0x81,
	0x75, 0xf1, 0xd7, 0x0c, 0xe4, 0x1f, 0x12, 0xd7, 0xec, 0x13, 0x7e, 0xd8, 0xf4, 0xe9, 0x88, 0xd8,
	0xd8, 0x47, 0x77, 0x20, 0x63, 0xda, 0xb6, 0xaf, 0x29, 0x6b, 0x4a, 0x69, 0xbe, 0xaa, 0xbd, 0x7c,
	0xb6, 0x5e, 0x08, 0x2b, 0xdd, 0xb2, 0x6d, 0x1f, 0x33, 0xd6, 0xe2, 0x3e, 0x71, 0x1d, 0x5d, 0x5a,
	0xa1, 0x3a, 0xa8, 0x36, 0x66, 0x96, 0x4f, 0x3c, 0x4e, 0xa8, 0xab, 0xa5, 0xd6, 0x94, 0x92, 0xba,
	0xf9, 0xbf, 0x72, 0xe8, 0x11, 0x23, 0x22, 0xdf, 0xa6, 0x5c, 0x8b, 0x4d, 0xf5, 0xa4, 0x1f, 0x7a,
	0x02, 0x60, 0xd1, 0xc1, 0x80, 0x30, 0x26, 0xa2, 0xa4, 0x65, 0xea, 0xf5, 0xa3, 0xe3, 0xd5, 0xe5,
	0x20, 0x10, 0xb3, 0x7b, 0x65, 0x42, 0x2b, 0x03, 0x93, 0x77, 0xcb, 0x8f, 0xb1, 0x63, 0x5a, 0x87,
	0x35, 0x6c, 0xbd, 0x7c, 0xb6, 0x0e, 0x61, 0x9e, 0x1a, 0xb6, 0xf4, 0x44, 0x00, 0xb4, 0x0b, 0x33,
	0x1d, 0x6e, 0x19, 0x5e, 0x4f, 0xcb, 0xac, 0x29, 0xa5, 0x6c, 0xf5, 0xc1, 0xd1, 0xf1, 0xea, 0x7d,
	0x87, 0xf0, 0xee, 0xb0, 0x53, 0xb6, 0xe8, 0xa0, 0x12, 0xa2, 0xd4, 0x37, 0x3b, 0x6c, 0x9d, 0xd0,
	0xc9, 0xb1, 0xc2, 0x0f, 0x3d, 0xcc, 0xca, 0xd5, 0x46, 0xf3, 0xde, 0xfd, 0xbb, 0xcd, 0x61, 0xe7,
	0x73, 0x7c, 0xa8, 0x4f, 0x77, 0xb8, 0xd5, 0xec, 0xa1, 0x4f, 0x20, 0xed, 0x51, 0x4f, 0x9b, 0x96,
	0xaf, 0xf7, 0x7e, 0xf9, 0xcc, 0xa6, 0x97, 0x9b, 0x3e, 0xa5, 0x07, 0xbb, 0x07, 0x4d, 0xca, 0x18,
	0x96, 0x75, 0x54, 0xdb, 0xdb, 0xba, 0xf0, 0x43, 0xf7, 0x61, 0x89, 0xf5, 0x4d, 0xd6, 0xc5, 0xb6,
	0x11, 0xba, 0x1a, 0x5d, 0x4c, 0x9c, 0x2e, 0xd7, 0x66, 0xd6, 0x94, 0x52, 0x46, 0x2f, 0x84, 0xda,
	0x6a, 0xa0, 0x7c, 0x24, 0x75, 0xe8, 0x0e, 0xa0, 0xc8, 0x8b, 0x5b, 0x13, 0x8f, 0xd9, 0x35, 0xa5,
	0x94, 0xd3, 0xf3, 0x13, 0x0f, 0x6e, 0x85, 0xd6, 0x4b, 0x30, 0xf3, 0x9d, 0x49, 0xfa, 0xd8, 0xd6,
	0xe6, 0xd6, 0x94, 0xd2, 0x9c, 0x1e, 0x9e, 0xd0, 0x5d, 0x28, 0x74, 0x89, 0xd3, 0xc5, 0x8c, 0x1b,
	0x23, 0xca, 0xb1, 0x3d, 0x89, 0x33, 0x2f, 0xe3, 0xa0, 0x50, 0xb7, 0x2f, 0x54, 0x61, 0xa4, 0x55,
	0x50, 0x2d, 0xea, 0xb2, 0xe1, 0x00, 0xfb, 0x06, 0xb1, 0x35, 0x10, 0xdd, 0x10, 0xf0, 0x06, 0xa2,
	0x86, 0x5d, 0xfc, 0x3d, 0x05, 0xda, 0x69, 0xde, 0x7c, 0x49, 0x78, 0xf7, 0x09, 0xe6, 0x66, 0x02,
	0x7b, 0xe5, 0x6a, 0xb0, 0x5f, 0x82, 0x99, 0xb0, 0xe4, 0x94, 0x04, 0x2b, 0x3c, 0xa1, 0xff, 0x42,
	0x76, 0x44, 0x39, 0x71, 0x1d, 0xc3, 0xa3, 0x3f, 0x60, 0x5f, 0xb2, 0x26, 0xa3, 0xab, 0x81, 0xac,
	0x29, 0x44, 0x6f, 0xc0, 0x3d, 0xf3, 0xd6, 0xb8, 0x4f, 0xff, 0x23, 0xee, 0x33, 0x17, 0xc2, 0x7d,
	0xf6, 0x3c, 0xdc, 0x8b, 0xbf, 0xcd, 0x42, 0xae, 0xda, 0xde, 0xae, 0xe1, 0x3e, 0x76, 0x4c, 0x39,
	0x16, 0x1f, 0x82, 0x2a, 0xf8, 0x85, 0x7d, 0xe3, 0x42, 0x23, 0x09, 0x81, 0xb1, 0x10, 0x26, 0xda,
	0x90, 0xba, 0xd2, 0x11, 0x48, 0xbf, 0xe3, 0x08, 0x7c, 0x0b, 0x0b, 0x07, 0x9e, 0x11, 0x94, 0x64,
	0xf4, 0x09, 0x13, 0x2d, 0x48, 0x5f, 0xaa, 0x2e, 0xf5, 0xc0, 0xab, 0x8a, 0xca, 0x1e, 0x13, 0x26,
	0xc9, 0x10, 0x96, 0x61, 0x70, 0x32, 0xc0, 0x61, 0xb7, 0xd4, 0x50, 0xd6, 0x26, 0x03, 0x1c, 0x9a,
	0xf8, 0x3c, 0x39, 0x7a, 0x81, 0x89, 0xcf, 0xc3, 0x5e, 0xfe, 0x07, 0x00, 0xbb, 0xa7, 0x3a, 0x35,
	0x8f, 0xdd, 0xc9, 0x60, 0x2c, 0xc3, 0x3c, 0xa7, 0xdc, 0xec, 0x1b, 0xcc, 0xe4, 0x72, 0xca, 0x32,
	0xfa, 0x9c, 0x14, 0xb4, 0x4c, 0xe9, 0x1b, 0x55, 0x30, 0x96, 0xd3, 0x95, 0xd5, 0xe7, 0x27, 0xf9,
	0xc7, 0x92, 0x54, 0xa1, 0x9a, 0x0e, 0xb9, 0x37, 0xe4, 0x06, 0xb1, 0xc7, 0x72, 0xb6, 0x04, 0xa9,
	0x02, 0xcd, 0xae, 0x54, 0x34, 0xec, 0x31, 0xda, 0x04, 0x55, 0x12, 0x2d, 0x8c, 0xa6, 0xca, 0x16,
	0x5e, 0x3b, 0x3a, 0x5e, 0x15, 0x04, 0x69, 0x85, 0x9a, 0xf6, 0x58, 0x07, 0x16, 0x3d, 0xa3, 0xa7,
	0x90, 0xb3, 0x03, 0xea, 0x50, 0xdf, 0x60, 0xc4, 0xd1, 0xb2, 0xd2, 0xeb, 0xe3, 0xa3, 0xe3, 0xd5,
	0x0f, 0xde, 0x0e, 0xe0, 0x16, 0x71, 0x5c, 0x93, 0x0f, 0x7d, 0xac, 0x67, 0xa3, 0x88, 0x2d, 0xe2,
	0xa0, 0x3d, 0xc8, 0x59, 0x74, 0x84, 0x5d, 0xd3, 0xe5, 0x22, 0x01, 0xd3, 0x72, 0x6b, 0xe9, 0x92,
	0xba, 0x79, 0xf7, 0x1c, 0x32, 0x6c, 0x87, 0xb6, 0x5b, 0xb6, 0xe9, 0x05, 0x11, 0x82, 0xa8, 0x4c,
	0xcf, 0x4e, 0xc2, 0xb4, 0x88, 0xc3, 0xd0, 0xff, 0x61, 0x61, 0xe8, 0x76, 0xa8, 0x6b, 0x47, 0xdd,
	0x5b, 0x90, 0xb0, 0xe4, 0x22, 0xa9, 0xec, 0xdf, 0x17, 0x90, 0x17, 0xf4, 0x19, 0xba, 0x76, 0x34,
	0x20, 0xda, 0xa2, 0x64, 0xe3, 0xed, 0x73, 0x0a, 0xa8, 0xb6, 0xb7, 0xf7, 0x12, 0xd6, 0xfa, 0x62,
	0x87, 0x5b, 0x49, 0x81, 0xc8, 0xec, 0x99, 0xbe, 0x39, 0x60, 0xc6, 0x08, 0xfb, 0x72, 0xf5, 0xe4,
	0x83, 0xcc, 0x81, 0x74, 0x3f, 0x10, 0xa2, 0x5b, 0xb0, 0x20, 0x32, 0x73, 0xe2, 0x4d, 0xa8, 0x71,
	0x4d, 0x9a, 0x65, 0x3b, 0xdc, 0x6a, 0x13, 0x2f, 0x1c, 0xdf, 0x4f, 0x61, 0xa9, 0x36, 0x41, 0x6b,
	0x6f, 0x52, 0x79, 0xc3, 0x3d, 0xa0, 0xc2, 0x9f, 0x79, 0x82, 0x58, 0x72, 0x3e, 0x45, 0x43, 0xe5,
	0xd5, 0xa8, 0x67, 0xa5, 0xb4, 0x25, 0x84, 0xed, 0x71, 0xf1, 0xe7, 0x0c, 0x2c, 0x9e, 0xaa, 0x58,
	0x70, 0x36, 0x01, 0xcd, 0xc4, 0x4f, 0x8d, 0x81, 0xf9, 0x1b, 0x55, 0x52, 0x17, 0xa1, 0xca, 0xf7,
	0xb0, 0x94, 0xa0, 0xca, 0xc4, 0x5b, 0x70, 0x26, 0x7d, 0x79, 0xce, 0x14, 0x62, 0xce, 0x84, 0x91,
	0x05, 0x77, 0x0e, 0x60, 0x29, 0xe6, 0x4e, 0x22, 0x23, 0x93, 0xf7, 0xc0, 0xbb, 0x90, 0xa8, 0x10,
	0x91, 0x28, 0x4e, 0xc3, 0x90, 0x05, 0xcb, 0x51, 0x9e, 0x18, 0x3a, 0x46, 0x9c, 0xe0, 0xd2, 0x99,
	0x96, 0xc9, 0x6e, 0x9d, 0x93, 0x2c, 0x8a, 0x2e, 0xda, 0xa6, 0x6b, 0x93, 0x40, 0x51, 0x37, 0x5b,
	0xc4, 0x91, 0xb7, 0x8d, 0x03, 0x5a, 0x8c, 0x5f, 0x9c, 0x85, 0xb8, 0x07, 0x54, 0x5e, 0x2b, 0xea,
	0xe6, 0xfa, 0x39, 0x19, 0xce, 0x66, 0x88, 0x1e, 0xb7, 0xe3, 0x84, 0xbc, 0xd8, 0x82, 0x7f, 0xc7,
	0x1b, 0x81, 0xfa, 0xf1, 0x6a, 0x60, 0xe8, 0x01, 0x64, 0x6c, 0xdc, 0x67, 0x9a, 0xf2, 0xc6, 0x37,
	0x3a, 0xb1, 0x4f, 0x74, 0xe9, 0x51, 0xdc, 0x81, 0xe5, 0xb3, 0x83, 0x36, 0x5c, 0x1b, 0x8f, 0x51,
	0x05, 0x0a, 0xf1, 0x45, 0x66, 0x74, 0x4d, 0xd6, 0x0d, 0xa0, 0x13, 0x89, 0xb2, 0xfa, 0xb5, 0xe8,
	0x4a, 0x7b, 0x64, 0xb2, 0xae, 0x40, 0xa3, 0xf8, 0x8b, 0x02, 0xb9, 0x13, 0xc8, 0xa1, 0x47, 0x90,
	0xba, 0x82, 0xfd, 0x9f, 0xf2, 0x7a, 0xe8, 0x09, 0xa4, 0x05, 0x2d, 0x53, 0x97, 0xa7, 0xa5, 0x88,
	0x53, 0xfc, 0x51, 0x81, 0x1b, 0xe7, 0x32, 0x4a, 0xec, 0x4c, 0x8b, 0x8e, 0xae, 0xe4, 0xd3, 0xc5,
	0xa2, 0xa3, 0x66, 0x4f, 0x8c, 0xaf, 0x19, 0x64, 0x09, 0xa8, 0x9e, 0x92, 0x10, 0xaa, 0x66, 0x94,
	0x99, 0x15, 0x9f, 0x2b, 0x70, 0xa3, 0x85, 0xfb, 0xd8, 0xe2, 0x64, 0x84, 0x27, 0x4c, 0xae, 0x8b,
	0x4f, 0x2a, 0xd7, 0xc2, 0xe8, 0x36, 0x2c, 0x9e, 0xea, 0x45, 0xf0, 0x11, 0xa0, 0xe7, 0x4e, 0xb4,
	0x01, 0xb5, 0x61, 0x3e, 0xda, 0xae, 0x97, 0x5e, 0xf8, 0xb3, 0xe1, 0x62, 0x45, 0xeb, 0x70, 0xdd,
	0xc7, 0x62, 0x08, 0x7c, 0x6c, 0x1b, 0x61, 0x7c, 0xd6, 0x0b, 0xee, 0x08, 0x3d, 0x1f, 0xa9, 0x1e,
	0x0a, 0xf3, 0x56, 0xaf, 0xd8, 0x81, 0x85, 0x86, 0x6b, 0xf5, 0x87, 0xe2, 0xce, 0x94, 0x1f, 0x02,
	0xe8, 0x23, 0x48, 0xf7, 0xf0, 0xa1, 0x2c, 0x59, 0xdd, 0x2c, 0x25, 0x29, 0x9a, 0xf8, 0x17, 0x19,
	0x6d, 0x94, 0xdb, 0xbe, 0xe9, 0x32, 0xd3, 0x12, 0x1c, 0x14, 0x05, 0x08, 0x27, 0x54, 0x80, 0x69,
	0x4f, 0x04, 0x09, 0x5e, 0x47, 0x0f, 0x0e, 0xef, 0x3d, 0x85, 0xeb, 0x27, 0x28, 0xdd, 0xe2, 0x26,
	0x1f, 0x32, 0xa4, 0xc2, 0x6c, 0xb3, 0xbe, 0x53, 0x6b, 0xec, 0x7c, 0x96, 0x9f, 0x42, 0x59, 0x98,
	0xdb, 0xaf, 0xeb, 0x8d, 0x87, 0x8d, 0x7a, 0x2d, 0xaf, 0x20, 0x80, 0x99, 0xad, 0xed, 0x76, 0x63,
	0xbf, 0x9e, 0x4f, 0x09, 0xcd, 0xde, 0x4e, 0x75, 0x77, 0xa7, 0x56, 0xaf, 0xe5, 0xd3, 0xc2, 0xa9,
	0xfe, 0x55, 0xb3, 0xa1, 0xd7, 0x6b, 0xf9, 0x0c, 0x9a, 0x85, 0xf4, 0xd6, 0xce, 0xd7, 0xf9, 0xe9,
	0xea, 0xce, 0xf3, 0x57, 0x2b, 0xca, 0x8b, 0x57, 0x2b, 0xca, 0x9f, 0xaf, 0x56, 0x94, 0x9f, 0x5e,
	0xaf, 0x4c, 0xbd, 0x78, 0xbd, 0x32, 0xf5, 0xc7, 0xeb, 0x95, 0xa9, 0x6f, 0x2e, 0x80, 0xe6, 0x38,
	0xf9, 0x67, 0x26, 0xa1, 0xed, 0xcc, 0xc8, 0x7f, 0xad, 0x7b, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff,
	0x1b, 0x77, 0xba, 0x6e, 0x52, 0x0e, 0x00, 0x00,
}

func (m *FinalityProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalityProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalityProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsumerId) > 0 {
		i -= len(m.ConsumerId)
		copy(dAtA[i:], m.ConsumerId)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.ConsumerId)))
		i--
		dAtA[i] = 0x52
	}
	if m.HighestVotedHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.HighestVotedHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Commission != nil {
		{
			size := m.Commission.Size()
			i -= size
			if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinalityProviderWithMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalityProviderWithMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalityProviderWithMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighestVotedHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.HighestVotedHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.VotingPower != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BtcTipHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.BtcTipHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ParamsVersion != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.ParamsVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.BtcUndelegation != nil {
		{
			size, err := m.BtcUndelegation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.UnbondingTime != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.UnbondingTime))
		i--
		dAtA[i] = 0x70
	}
	if len(m.CovenantSigs) > 0 {
		for iNdEx := len(m.CovenantSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.DelegatorSig != nil {
		{
			size := m.DelegatorSig.Size()
			i -= size
			if _, err := m.DelegatorSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.StakingOutputIdx != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StakingOutputIdx))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StakingTx) > 0 {
		i -= len(m.StakingTx)
		copy(dAtA[i:], m.StakingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTx)))
		i--
		dAtA[i] = 0x4a
	}
	if m.TotalSat != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.TotalSat))
		i--
		dAtA[i] = 0x40
	}
	if m.EndHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.StartHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.StakingTime != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StakingTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FpBtcPkList) > 0 {
		for iNdEx := len(m.FpBtcPkList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.FpBtcPkList[iNdEx].Size()
				i -= size
				if _, err := m.FpBtcPkList[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddr) > 0 {
		i -= len(m.StakerAddr)
		copy(dAtA[i:], m.StakerAddr)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakerAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorUnbondingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorUnbondingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorUnbondingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpendStakeTx) > 0 {
		i -= len(m.SpendStakeTx)
		copy(dAtA[i:], m.SpendStakeTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.SpendStakeTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorUnbondingInfo != nil {
		{
			size, err := m.DelegatorUnbondingInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CovenantUnbondingSigList) > 0 {
		for iNdEx := len(m.CovenantUnbondingSigList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantUnbondingSigList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CovenantSlashingSigs) > 0 {
		for iNdEx := len(m.CovenantSlashingSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantSlashingSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DelegatorSlashingSig != nil {
		{
			size := m.DelegatorSlashingSig.Size()
			i -= size
			if _, err := m.DelegatorSlashingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UnbondingTx) > 0 {
		i -= len(m.UnbondingTx)
		copy(dAtA[i:], m.UnbondingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.UnbondingTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for iNdEx := len(m.Dels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegationIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegationIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegationIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakingTxHashList) > 0 {
		for iNdEx := len(m.StakingTxHashList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StakingTxHashList[iNdEx])
			copy(dAtA[i:], m.StakingTxHashList[iNdEx])
			i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTxHashList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignatureInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sig != nil {
		{
			size := m.Sig.Size()
			i -= size
			if _, err := m.Sig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pk != nil {
		{
			size := m.Pk.Size()
			i -= size
			if _, err := m.Pk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CovenantAdaptorSignatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CovenantAdaptorSignatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CovenantAdaptorSignatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdaptorSigs) > 0 {
		for iNdEx := len(m.AdaptorSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AdaptorSigs[iNdEx])
			copy(dAtA[i:], m.AdaptorSigs[iNdEx])
			i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.AdaptorSigs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CovPk != nil {
		{
			size := m.CovPk.Size()
			i -= size
			if _, err := m.CovPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SelectiveSlashingEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelectiveSlashingEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SelectiveSlashingEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecoveredFpBtcSk) > 0 {
		i -= len(m.RecoveredFpBtcSk)
		copy(dAtA[i:], m.RecoveredFpBtcSk)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.RecoveredFpBtcSk)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FpBtcPk != nil {
		{
			size := m.FpBtcPk.Size()
			i -= size
			if _, err := m.FpBtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakingTxHash) > 0 {
		i -= len(m.StakingTxHash)
		copy(dAtA[i:], m.StakingTxHash)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InclusionProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InclusionProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InclusionProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBtcstaking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBtcstaking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FinalityProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Commission != nil {
		l = m.Commission.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	if m.Jailed {
		n += 2
	}
	if m.HighestVotedHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.HighestVotedHeight))
	}
	l = len(m.ConsumerId)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *FinalityProviderWithMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovBtcstaking(uint64(m.Height))
	}
	if m.VotingPower != 0 {
		n += 1 + sovBtcstaking(uint64(m.VotingPower))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	if m.Jailed {
		n += 2
	}
	if m.HighestVotedHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.HighestVotedHeight))
	}
	return n
}

func (m *BTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddr)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.FpBtcPkList) > 0 {
		for _, e := range m.FpBtcPkList {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.StakingTime != 0 {
		n += 1 + sovBtcstaking(uint64(m.StakingTime))
	}
	if m.StartHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.EndHeight))
	}
	if m.TotalSat != 0 {
		n += 1 + sovBtcstaking(uint64(m.TotalSat))
	}
	l = len(m.StakingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.StakingOutputIdx != 0 {
		n += 1 + sovBtcstaking(uint64(m.StakingOutputIdx))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSig != nil {
		l = m.DelegatorSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.CovenantSigs) > 0 {
		for _, e := range m.CovenantSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.UnbondingTime != 0 {
		n += 1 + sovBtcstaking(uint64(m.UnbondingTime))
	}
	if m.BtcUndelegation != nil {
		l = m.BtcUndelegation.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.ParamsVersion != 0 {
		n += 2 + sovBtcstaking(uint64(m.ParamsVersion))
	}
	if m.BtcTipHeight != 0 {
		n += 2 + sovBtcstaking(uint64(m.BtcTipHeight))
	}
	return n
}

func (m *DelegatorUnbondingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpendStakeTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCUndelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnbondingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSlashingSig != nil {
		l = m.DelegatorSlashingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.CovenantSlashingSigs) > 0 {
		for _, e := range m.CovenantSlashingSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if len(m.CovenantUnbondingSigList) > 0 {
		for _, e := range m.CovenantUnbondingSigList {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.DelegatorUnbondingInfo != nil {
		l = m.DelegatorUnbondingInfo.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCDelegatorDelegations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for _, e := range m.Dels {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *BTCDelegatorDelegationIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StakingTxHashList) > 0 {
		for _, b := range m.StakingTxHashList {
			l = len(b)
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *SignatureInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pk != nil {
		l = m.Pk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Sig != nil {
		l = m.Sig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *CovenantAdaptorSignatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CovPk != nil {
		l = m.CovPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.AdaptorSigs) > 0 {
		for _, b := range m.AdaptorSigs {
			l = len(b)
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *SelectiveSlashingEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakingTxHash)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.FpBtcPk != nil {
		l = m.FpBtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.RecoveredFpBtcSk)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *InclusionProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func sovBtcstaking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBtcstaking(x uint64) (n int) {
	return sovBtcstaking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FinalityProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalityProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalityProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &types.Description{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.Commission = &v
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossessionBTC{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestVotedHeight", wireType)
			}
			m.HighestVotedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestVotedHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalityProviderWithMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalityProviderWithMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalityProviderWithMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestVotedHeight", wireType)
			}
			m.HighestVotedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestVotedHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossessionBTC{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpBtcPkList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.FpBtcPkList = append(m.FpBtcPkList, v)
			if err := m.FpBtcPkList[len(m.FpBtcPkList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTime", wireType)
			}
			m.StakingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			m.TotalSat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTx = append(m.StakingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.StakingTx == nil {
				m.StakingTx = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingOutputIdx", wireType)
			}
			m.StakingOutputIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingOutputIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340Signature
			m.DelegatorSig = &v
			if err := m.DelegatorSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantSigs = append(m.CovenantSigs, &CovenantAdaptorSignatures{})
			if err := m.CovenantSigs[len(m.CovenantSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTime", wireType)
			}
			m.UnbondingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcUndelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BtcUndelegation == nil {
				m.BtcUndelegation = &BTCUndelegation{}
			}
			if err := m.BtcUndelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsVersion", wireType)
			}
			m.ParamsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamsVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcTipHeight", wireType)
			}
			m.BtcTipHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BtcTipHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorUnbondingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorUnbondingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorUnbondingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendStakeTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendStakeTx = append(m.SpendStakeTx[:0], dAtA[iNdEx:postIndex]...)
			if m.SpendStakeTx == nil {
				m.SpendStakeTx = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondingTx = append(m.UnbondingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.UnbondingTx == nil {
				m.UnbondingTx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340Signature
			m.DelegatorSlashingSig = &v
			if err := m.DelegatorSlashingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSlashingSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantSlashingSigs = append(m.CovenantSlashingSigs, &CovenantAdaptorSignatures{})
			if err := m.CovenantSlashingSigs[len(m.CovenantSlashingSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantUnbondingSigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantUnbondingSigList = append(m.CovenantUnbondingSigList, &SignatureInfo{})
			if err := m.CovenantUnbondingSigList[len(m.CovenantUnbondingSigList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorUnbondingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorUnbondingInfo == nil {
				m.DelegatorUnbondingInfo = &DelegatorUnbondingInfo{}
			}
			if err := m.DelegatorUnbondingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dels = append(m.Dels, &BTCDelegation{})
			if err := m.Dels[len(m.Dels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegationIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegationIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegationIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTxHashList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTxHashList = append(m.StakingTxHashList, make([]byte, postIndex-iNdEx))
			copy(m.StakingTxHashList[len(m.StakingTxHashList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.Pk = &v
			if err := m.Pk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340Signature
			m.Sig = &v
			if err := m.Sig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CovenantAdaptorSignatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CovenantAdaptorSignatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CovenantAdaptorSignatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.CovPk = &v
			if err := m.CovPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptorSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdaptorSigs = append(m.AdaptorSigs, make([]byte, postIndex-iNdEx))
			copy(m.AdaptorSigs[len(m.AdaptorSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelectiveSlashingEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelectiveSlashingEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelectiveSlashingEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpBtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_types.BIP340PubKey
			m.FpBtcPk = &v
			if err := m.FpBtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveredFpBtcSk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveredFpBtcSk = append(m.RecoveredFpBtcSk[:0], dAtA[iNdEx:postIndex]...)
			if m.RecoveredFpBtcSk == nil {
				m.RecoveredFpBtcSk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InclusionProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InclusionProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InclusionProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &types1.TransactionKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBtcstaking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBtcstaking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBtcstaking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBtcstaking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBtcstaking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBtcstaking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBtcstaking = fmt.Errorf("proto: unexpected end of group")
)
