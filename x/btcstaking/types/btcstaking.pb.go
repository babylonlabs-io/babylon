// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/btcstaking/v1/btcstaking.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_babylonlabs_io_babylon_v4_types "github.com/babylonlabs-io/babylon/v4/types"
	types1 "github.com/babylonlabs-io/babylon/v4/x/btccheckpoint/types"
	types2 "github.com/babylonlabs-io/babylon/v4/x/btclightclient/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	types "github.com/cosmos/cosmos-sdk/x/staking/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BTCDelegationStatus is the status of a delegation.
// There are two possible valid state transition paths for a BTC delegation:
// - PENDING -> VERIFIED -> ACTIVE -> UNBONDED -> EXPIRED
// - PENDING -> VERIFIED -> ACTIVE -> UNBONDED/EXPIRED
// and one invalid state transition path:
// - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
// activating delegation on Babylon chain.
// In valid transition paths, the delegation becomes UNBONDED when:
// - either the staking transaction timelock expires
// - or the staker requests early undelegation through MsgBTCUndelegate message.
type BTCDelegationStatus int32

const (
	// PENDING defines a delegation that is waiting for covenant signatures.
	BTCDelegationStatus_PENDING BTCDelegationStatus = 0
	// VERIFIED defines a delegation that has covenant signatures but is not yet
	// included in the BTC chain.
	BTCDelegationStatus_VERIFIED BTCDelegationStatus = 1
	// ACTIVE defines a delegation that has voting power
	BTCDelegationStatus_ACTIVE BTCDelegationStatus = 2
	// UNBONDED defines a delegation no longer has voting power
	// by receiving unbonding tx with signatures from staker and covenant
	// committee
	BTCDelegationStatus_UNBONDED BTCDelegationStatus = 3
	// EXPIRED defines a delegation no longer has voting power
	// for reaching the end of staking transaction timelock
	BTCDelegationStatus_EXPIRED BTCDelegationStatus = 4
	// ANY is any of the above status
	BTCDelegationStatus_ANY BTCDelegationStatus = 5
)

var BTCDelegationStatus_name = map[int32]string{
	0: "PENDING",
	1: "VERIFIED",
	2: "ACTIVE",
	3: "UNBONDED",
	4: "EXPIRED",
	5: "ANY",
}

var BTCDelegationStatus_value = map[string]int32{
	"PENDING":  0,
	"VERIFIED": 1,
	"ACTIVE":   2,
	"UNBONDED": 3,
	"EXPIRED":  4,
	"ANY":      5,
}

func (x BTCDelegationStatus) String() string {
	return proto.EnumName(BTCDelegationStatus_name, int32(x))
}

func (BTCDelegationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}

// FinalityProvider defines a finality provider
type FinalityProvider struct {
	// addr is the bech32 address identifier of the finality provider.
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// description defines the description terms for the finality provider.
	Description *types.Description `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// commission defines the commission rate of the finality provider.
	Commission *cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=commission,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"commission,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this finality provider
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,4,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of the btc_pk, where the BTC
	// private key signs the bech32 bbn addr of the finality provider.
	Pop *ProofOfPossessionBTC `protobuf:"bytes,5,opt,name=pop,proto3" json:"pop,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,6,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBtcHeight uint32 `protobuf:"varint,7,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
	// jailed defines whether the finality provider is jailed
	Jailed bool `protobuf:"varint,8,opt,name=jailed,proto3" json:"jailed,omitempty"`
	// highest_voted_height is the highest height for which the
	// finality provider has voted
	HighestVotedHeight uint32 `protobuf:"varint,9,opt,name=highest_voted_height,json=highestVotedHeight,proto3" json:"highest_voted_height,omitempty"`
	// commission_info contains information details of the finality provider commission.
	CommissionInfo *CommissionInfo `protobuf:"bytes,11,opt,name=commission_info,json=commissionInfo,proto3" json:"commission_info,omitempty"`
}

func (m *FinalityProvider) Reset()         { *m = FinalityProvider{} }
func (m *FinalityProvider) String() string { return proto.CompactTextString(m) }
func (*FinalityProvider) ProtoMessage()    {}
func (*FinalityProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}
func (m *FinalityProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalityProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalityProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalityProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalityProvider.Merge(m, src)
}
func (m *FinalityProvider) XXX_Size() int {
	return m.Size()
}
func (m *FinalityProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalityProvider.DiscardUnknown(m)
}

var xxx_messageInfo_FinalityProvider proto.InternalMessageInfo

func (m *FinalityProvider) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *FinalityProvider) GetDescription() *types.Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *FinalityProvider) GetPop() *ProofOfPossessionBTC {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *FinalityProvider) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *FinalityProvider) GetSlashedBtcHeight() uint32 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

func (m *FinalityProvider) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *FinalityProvider) GetHighestVotedHeight() uint32 {
	if m != nil {
		return m.HighestVotedHeight
	}
	return 0
}

func (m *FinalityProvider) GetCommissionInfo() *CommissionInfo {
	if m != nil {
		return m.CommissionInfo
	}
	return nil
}

// CommissionInfo defines the information related to the commission of
// a finality provider.
type CommissionInfo struct {
	// max_rate defines the maximum commission rate which validator can ever charge, as a fraction.
	MaxRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=max_rate,json=maxRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_rate"`
	// max_change_rate defines the maximum daily increase of the validator commission, as a fraction.
	MaxChangeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=max_change_rate,json=maxChangeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_change_rate"`
	// update_time is the last time the commission rate was changed.
	UpdateTime time.Time `protobuf:"bytes,3,opt,name=update_time,json=updateTime,proto3,stdtime" json:"update_time"`
}

func (m *CommissionInfo) Reset()         { *m = CommissionInfo{} }
func (m *CommissionInfo) String() string { return proto.CompactTextString(m) }
func (*CommissionInfo) ProtoMessage()    {}
func (*CommissionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{1}
}
func (m *CommissionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommissionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommissionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommissionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommissionInfo.Merge(m, src)
}
func (m *CommissionInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommissionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommissionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommissionInfo proto.InternalMessageInfo

func (m *CommissionInfo) GetUpdateTime() time.Time {
	if m != nil {
		return m.UpdateTime
	}
	return time.Time{}
}

// FinalityProviderWithMeta wraps the FinalityProvider with metadata.
type FinalityProviderWithMeta struct {
	// btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,1,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// height is the queried Babylon height
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// voting_power is the voting power of this finality provider at the given
	// height
	VotingPower uint64 `protobuf:"varint,3,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,4,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the finality provider is slashed.
	// if it's 0 then the finality provider is not slashed
	SlashedBtcHeight uint32 `protobuf:"varint,5,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
	// jailed defines whether the finality provider is detected jailed
	Jailed bool `protobuf:"varint,6,opt,name=jailed,proto3" json:"jailed,omitempty"`
	// highest_voted_height is the highest height for which the
	// finality provider has voted
	HighestVotedHeight uint32 `protobuf:"varint,7,opt,name=highest_voted_height,json=highestVotedHeight,proto3" json:"highest_voted_height,omitempty"`
}

func (m *FinalityProviderWithMeta) Reset()         { *m = FinalityProviderWithMeta{} }
func (m *FinalityProviderWithMeta) String() string { return proto.CompactTextString(m) }
func (*FinalityProviderWithMeta) ProtoMessage()    {}
func (*FinalityProviderWithMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{2}
}
func (m *FinalityProviderWithMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalityProviderWithMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalityProviderWithMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalityProviderWithMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalityProviderWithMeta.Merge(m, src)
}
func (m *FinalityProviderWithMeta) XXX_Size() int {
	return m.Size()
}
func (m *FinalityProviderWithMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalityProviderWithMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FinalityProviderWithMeta proto.InternalMessageInfo

func (m *FinalityProviderWithMeta) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetSlashedBtcHeight() uint32 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

func (m *FinalityProviderWithMeta) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *FinalityProviderWithMeta) GetHighestVotedHeight() uint32 {
	if m != nil {
		return m.HighestVotedHeight
	}
	return 0
}

// BTCDelegation defines a BTC delegation
type BTCDelegation struct {
	// staker_addr is the address to receive rewards from BTC delegation.
	StakerAddr string `protobuf:"bytes,1,opt,name=staker_addr,json=stakerAddr,proto3" json:"staker_addr,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,2,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossessionBTC `protobuf:"bytes,3,opt,name=pop,proto3" json:"pop,omitempty"`
	// fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
	// this BTC delegation delegates to
	// If there is more than 1 PKs, then this means the delegation is restaked
	// to multiple finality providers
	FpBtcPkList []github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,4,rep,name=fp_btc_pk_list,json=fpBtcPkList,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"fp_btc_pk_list,omitempty"`
	// staking_time is the number of blocks for which the delegation is locked on
	// BTC chain
	StakingTime uint32 `protobuf:"varint,5,opt,name=staking_time,json=stakingTime,proto3" json:"staking_time,omitempty"`
	// start_height is the start BTC height of the BTC delegation
	// it is the start BTC height of the timelock
	StartHeight uint32 `protobuf:"varint,6,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is the end height of the BTC delegation
	// it is calculated by end_height = start_height + staking_time
	EndHeight uint32 `protobuf:"varint,7,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// total_sat is the total amount of BTC stakes in this delegation
	// quantified in satoshi
	TotalSat uint64 `protobuf:"varint,8,opt,name=total_sat,json=totalSat,proto3" json:"total_sat,omitempty"`
	// staking_tx is the staking tx
	StakingTx []byte `protobuf:"bytes,9,opt,name=staking_tx,json=stakingTx,proto3" json:"staking_tx,omitempty"`
	// staking_output_idx is the index of the staking output in the staking tx
	StakingOutputIdx uint32 `protobuf:"varint,10,opt,name=staking_output_idx,json=stakingOutputIdx,proto3" json:"staking_output_idx,omitempty"`
	// slashing_tx is the slashing tx
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// finality provider or covenant yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,11,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the staking tx output.
	DelegatorSig *github_com_babylonlabs_io_babylon_v4_types.BIP340Signature `protobuf:"bytes,12,opt,name=delegator_sig,json=delegatorSig,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340Signature" json:"delegator_sig,omitempty"`
	// covenant_sigs is a list of adaptor signatures on the slashing tx
	// by each covenant member
	// It will be a part of the witness for the staking tx output.
	CovenantSigs []*CovenantAdaptorSignatures `protobuf:"bytes,13,rep,name=covenant_sigs,json=covenantSigs,proto3" json:"covenant_sigs,omitempty"`
	// unbonding_time describes how long the funds will be locked either in
	// unbonding output or slashing change output
	UnbondingTime uint32 `protobuf:"varint,14,opt,name=unbonding_time,json=unbondingTime,proto3" json:"unbonding_time,omitempty"`
	// btc_undelegation is the information about the early unbonding path of the
	// BTC delegation
	BtcUndelegation *BTCUndelegation `protobuf:"bytes,15,opt,name=btc_undelegation,json=btcUndelegation,proto3" json:"btc_undelegation,omitempty"`
	// version of the params used to validate the delegation
	ParamsVersion uint32 `protobuf:"varint,16,opt,name=params_version,json=paramsVersion,proto3" json:"params_version,omitempty"`
	// btc_tip_height is the height of the BTC light client tip at the time of
	// the delegation creation
	BtcTipHeight uint32 `protobuf:"varint,17,opt,name=btc_tip_height,json=btcTipHeight,proto3" json:"btc_tip_height,omitempty"`
	// stk_exp is contains the relevant information about the previous staking that
	// originated this stake. If nil it is NOT a stake expansion.
	StkExp *StakeExpansion `protobuf:"bytes,18,opt,name=stk_exp,json=stkExp,proto3" json:"stk_exp,omitempty"`
	// extra_staker_info is used when the given btc delegation is M-of-N multisig.
	// If nil, it is not a M-of-N multisig.
	ExtraStakerInfo *AdditionalStakerInfo `protobuf:"bytes,19,opt,name=extra_staker_info,json=extraStakerInfo,proto3" json:"extra_staker_info,omitempty"`
}

func (m *BTCDelegation) Reset()         { *m = BTCDelegation{} }
func (m *BTCDelegation) String() string { return proto.CompactTextString(m) }
func (*BTCDelegation) ProtoMessage()    {}
func (*BTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{3}
}
func (m *BTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegation.Merge(m, src)
}
func (m *BTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegation proto.InternalMessageInfo

func (m *BTCDelegation) GetStakerAddr() string {
	if m != nil {
		return m.StakerAddr
	}
	return ""
}

func (m *BTCDelegation) GetPop() *ProofOfPossessionBTC {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCDelegation) GetStakingTime() uint32 {
	if m != nil {
		return m.StakingTime
	}
	return 0
}

func (m *BTCDelegation) GetStartHeight() uint32 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *BTCDelegation) GetEndHeight() uint32 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *BTCDelegation) GetTotalSat() uint64 {
	if m != nil {
		return m.TotalSat
	}
	return 0
}

func (m *BTCDelegation) GetStakingTx() []byte {
	if m != nil {
		return m.StakingTx
	}
	return nil
}

func (m *BTCDelegation) GetStakingOutputIdx() uint32 {
	if m != nil {
		return m.StakingOutputIdx
	}
	return 0
}

func (m *BTCDelegation) GetCovenantSigs() []*CovenantAdaptorSignatures {
	if m != nil {
		return m.CovenantSigs
	}
	return nil
}

func (m *BTCDelegation) GetUnbondingTime() uint32 {
	if m != nil {
		return m.UnbondingTime
	}
	return 0
}

func (m *BTCDelegation) GetBtcUndelegation() *BTCUndelegation {
	if m != nil {
		return m.BtcUndelegation
	}
	return nil
}

func (m *BTCDelegation) GetParamsVersion() uint32 {
	if m != nil {
		return m.ParamsVersion
	}
	return 0
}

func (m *BTCDelegation) GetBtcTipHeight() uint32 {
	if m != nil {
		return m.BtcTipHeight
	}
	return 0
}

func (m *BTCDelegation) GetStkExp() *StakeExpansion {
	if m != nil {
		return m.StkExp
	}
	return nil
}

func (m *BTCDelegation) GetExtraStakerInfo() *AdditionalStakerInfo {
	if m != nil {
		return m.ExtraStakerInfo
	}
	return nil
}

// StakeExpansion stores information necessary to construct the expanded BTC staking
// transaction created from a previous BTC staking.
type StakeExpansion struct {
	// previous_staking_tx_hash is the hash of the staking tx that was used as
	// input to the stake expansion.
	PreviousStakingTxHash []byte `protobuf:"bytes,1,opt,name=previous_staking_tx_hash,json=previousStakingTxHash,proto3" json:"previous_staking_tx_hash,omitempty"`
	// other_funding_tx_out is the other funding output (TxOut) which was used
	// as input to construct the BTC delegation. The stake expansion has a set of
	// 2 inputs, the first input is the previous staking transaction and the
	// second input (this one) is to pay for fees and optionally to add more
	// stake to the BTC delegation.
	OtherFundingTxOut []byte `protobuf:"bytes,2,opt,name=other_funding_tx_out,json=otherFundingTxOut,proto3" json:"other_funding_tx_out,omitempty"`
	// previous_stk_covenant_sigs is a list of signatures on the stake expansion
	// transaction (i.e., the transaction spending the previous staking transaction
	// {previous_staking_tx_hash}) by each covenant member.
	// It must be provided to allow the previous staking tx to be spent as
	// an transaction input of another BTC staking transaction.
	PreviousStkCovenantSigs []*SignatureInfo `protobuf:"bytes,3,rep,name=previous_stk_covenant_sigs,json=previousStkCovenantSigs,proto3" json:"previous_stk_covenant_sigs,omitempty"`
}

func (m *StakeExpansion) Reset()         { *m = StakeExpansion{} }
func (m *StakeExpansion) String() string { return proto.CompactTextString(m) }
func (*StakeExpansion) ProtoMessage()    {}
func (*StakeExpansion) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{4}
}
func (m *StakeExpansion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakeExpansion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakeExpansion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakeExpansion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakeExpansion.Merge(m, src)
}
func (m *StakeExpansion) XXX_Size() int {
	return m.Size()
}
func (m *StakeExpansion) XXX_DiscardUnknown() {
	xxx_messageInfo_StakeExpansion.DiscardUnknown(m)
}

var xxx_messageInfo_StakeExpansion proto.InternalMessageInfo

func (m *StakeExpansion) GetPreviousStakingTxHash() []byte {
	if m != nil {
		return m.PreviousStakingTxHash
	}
	return nil
}

func (m *StakeExpansion) GetOtherFundingTxOut() []byte {
	if m != nil {
		return m.OtherFundingTxOut
	}
	return nil
}

func (m *StakeExpansion) GetPreviousStkCovenantSigs() []*SignatureInfo {
	if m != nil {
		return m.PreviousStkCovenantSigs
	}
	return nil
}

// DelegatorUnbondingInfo contains the information about transaction which spent
// the staking output. It contains:
// - spend_stake_tx: the transaction which spent the staking output
type DelegatorUnbondingInfo struct {
	// spend_stake_tx is the transaction which spent the staking output. It is
	// filled only if spend_stake_tx is different than unbonding_tx registered
	// on the Babylon chain.
	SpendStakeTx []byte `protobuf:"bytes,1,opt,name=spend_stake_tx,json=spendStakeTx,proto3" json:"spend_stake_tx,omitempty"`
}

func (m *DelegatorUnbondingInfo) Reset()         { *m = DelegatorUnbondingInfo{} }
func (m *DelegatorUnbondingInfo) String() string { return proto.CompactTextString(m) }
func (*DelegatorUnbondingInfo) ProtoMessage()    {}
func (*DelegatorUnbondingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{5}
}
func (m *DelegatorUnbondingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorUnbondingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorUnbondingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorUnbondingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorUnbondingInfo.Merge(m, src)
}
func (m *DelegatorUnbondingInfo) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorUnbondingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorUnbondingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorUnbondingInfo proto.InternalMessageInfo

func (m *DelegatorUnbondingInfo) GetSpendStakeTx() []byte {
	if m != nil {
		return m.SpendStakeTx
	}
	return nil
}

// BTCUndelegation contains the information about the early unbonding path of
// the BTC delegation
type BTCUndelegation struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower
	// timelock than staking output.
	UnbondingTx []byte `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// slashing_tx is the slashing tx for unbonding transactions
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// finality provider or covenant yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,2,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_slashing_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the unbonding tx output.
	DelegatorSlashingSig *github_com_babylonlabs_io_babylon_v4_types.BIP340Signature `protobuf:"bytes,3,opt,name=delegator_slashing_sig,json=delegatorSlashingSig,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340Signature" json:"delegator_slashing_sig,omitempty"`
	// covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
	// by each covenant member
	// It will be a part of the witness for the staking tx output.
	CovenantSlashingSigs []*CovenantAdaptorSignatures `protobuf:"bytes,4,rep,name=covenant_slashing_sigs,json=covenantSlashingSigs,proto3" json:"covenant_slashing_sigs,omitempty"`
	// covenant_unbonding_sig_list is the list of signatures on the unbonding tx
	// by covenant members
	// It must be provided after processing undelegate message by Babylon
	CovenantUnbondingSigList []*SignatureInfo `protobuf:"bytes,5,rep,name=covenant_unbonding_sig_list,json=covenantUnbondingSigList,proto3" json:"covenant_unbonding_sig_list,omitempty"`
	// delegator_unbonding_info is the information about transaction which spent
	// the staking output
	DelegatorUnbondingInfo *DelegatorUnbondingInfo `protobuf:"bytes,6,opt,name=delegator_unbonding_info,json=delegatorUnbondingInfo,proto3" json:"delegator_unbonding_info,omitempty"`
}

func (m *BTCUndelegation) Reset()         { *m = BTCUndelegation{} }
func (m *BTCUndelegation) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegation) ProtoMessage()    {}
func (*BTCUndelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{6}
}
func (m *BTCUndelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegation.Merge(m, src)
}
func (m *BTCUndelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegation proto.InternalMessageInfo

func (m *BTCUndelegation) GetUnbondingTx() []byte {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

func (m *BTCUndelegation) GetCovenantSlashingSigs() []*CovenantAdaptorSignatures {
	if m != nil {
		return m.CovenantSlashingSigs
	}
	return nil
}

func (m *BTCUndelegation) GetCovenantUnbondingSigList() []*SignatureInfo {
	if m != nil {
		return m.CovenantUnbondingSigList
	}
	return nil
}

func (m *BTCUndelegation) GetDelegatorUnbondingInfo() *DelegatorUnbondingInfo {
	if m != nil {
		return m.DelegatorUnbondingInfo
	}
	return nil
}

// BTCDelegatorDelegations is a collection of BTC delegations from the same
// delegator.
type BTCDelegatorDelegations struct {
	Dels []*BTCDelegation `protobuf:"bytes,1,rep,name=dels,proto3" json:"dels,omitempty"`
}

func (m *BTCDelegatorDelegations) Reset()         { *m = BTCDelegatorDelegations{} }
func (m *BTCDelegatorDelegations) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegations) ProtoMessage()    {}
func (*BTCDelegatorDelegations) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{7}
}
func (m *BTCDelegatorDelegations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegations.Merge(m, src)
}
func (m *BTCDelegatorDelegations) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegations) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegations.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegations proto.InternalMessageInfo

func (m *BTCDelegatorDelegations) GetDels() []*BTCDelegation {
	if m != nil {
		return m.Dels
	}
	return nil
}

// BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations
// from the same delegator.
type BTCDelegatorDelegationIndex struct {
	StakingTxHashList [][]byte `protobuf:"bytes,1,rep,name=staking_tx_hash_list,json=stakingTxHashList,proto3" json:"staking_tx_hash_list,omitempty"`
}

func (m *BTCDelegatorDelegationIndex) Reset()         { *m = BTCDelegatorDelegationIndex{} }
func (m *BTCDelegatorDelegationIndex) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegationIndex) ProtoMessage()    {}
func (*BTCDelegatorDelegationIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{8}
}
func (m *BTCDelegatorDelegationIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegationIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegationIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegationIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegationIndex.Merge(m, src)
}
func (m *BTCDelegatorDelegationIndex) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegationIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegationIndex.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegationIndex proto.InternalMessageInfo

func (m *BTCDelegatorDelegationIndex) GetStakingTxHashList() [][]byte {
	if m != nil {
		return m.StakingTxHashList
	}
	return nil
}

// SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK
type SignatureInfo struct {
	Pk  *github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey    `protobuf:"bytes,1,opt,name=pk,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"pk,omitempty"`
	Sig *github_com_babylonlabs_io_babylon_v4_types.BIP340Signature `protobuf:"bytes,2,opt,name=sig,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340Signature" json:"sig,omitempty"`
}

func (m *SignatureInfo) Reset()         { *m = SignatureInfo{} }
func (m *SignatureInfo) String() string { return proto.CompactTextString(m) }
func (*SignatureInfo) ProtoMessage()    {}
func (*SignatureInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{9}
}
func (m *SignatureInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureInfo.Merge(m, src)
}
func (m *SignatureInfo) XXX_Size() int {
	return m.Size()
}
func (m *SignatureInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureInfo proto.InternalMessageInfo

// CovenantAdaptorSignatures is a list adaptor signatures signed by the
// covenant with different finality provider's public keys as encryption keys
type CovenantAdaptorSignatures struct {
	// cov_pk is the public key of the covenant emulator, used as the public key
	// of the adaptor signature
	CovPk *github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,1,opt,name=cov_pk,json=covPk,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"cov_pk,omitempty"`
	// adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked
	// BTC finality provider's public key
	AdaptorSigs [][]byte `protobuf:"bytes,2,rep,name=adaptor_sigs,json=adaptorSigs,proto3" json:"adaptor_sigs,omitempty"`
}

func (m *CovenantAdaptorSignatures) Reset()         { *m = CovenantAdaptorSignatures{} }
func (m *CovenantAdaptorSignatures) String() string { return proto.CompactTextString(m) }
func (*CovenantAdaptorSignatures) ProtoMessage()    {}
func (*CovenantAdaptorSignatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{10}
}
func (m *CovenantAdaptorSignatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CovenantAdaptorSignatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CovenantAdaptorSignatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CovenantAdaptorSignatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CovenantAdaptorSignatures.Merge(m, src)
}
func (m *CovenantAdaptorSignatures) XXX_Size() int {
	return m.Size()
}
func (m *CovenantAdaptorSignatures) XXX_DiscardUnknown() {
	xxx_messageInfo_CovenantAdaptorSignatures.DiscardUnknown(m)
}

var xxx_messageInfo_CovenantAdaptorSignatures proto.InternalMessageInfo

func (m *CovenantAdaptorSignatures) GetAdaptorSigs() [][]byte {
	if m != nil {
		return m.AdaptorSigs
	}
	return nil
}

// SelectiveSlashingEvidence is the evidence that the finality provider
// selectively slashed a BTC delegation
// NOTE: it's possible that a slashed finality provider exploits the
// SelectiveSlashingEvidence endpoint while it is actually slashed due to
// equivocation. But such behaviour does not affect the system's security
// or gives any benefit for the adversary
type SelectiveSlashingEvidence struct {
	// fp_btc_pk is the BTC PK of the finality provider who
	// launches the selective slashing offence
	FpBtcPk *github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,2,opt,name=fp_btc_pk,json=fpBtcPk,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"fp_btc_pk,omitempty"`
	// recovered_fp_btc_sk is the finality provider's BTC SK recovered from
	// the covenant adaptor/Schnorr signature pair. It is the consequence
	// of selective slashing.
	RecoveredFpBtcSk []byte `protobuf:"bytes,3,opt,name=recovered_fp_btc_sk,json=recoveredFpBtcSk,proto3" json:"recovered_fp_btc_sk,omitempty"`
}

func (m *SelectiveSlashingEvidence) Reset()         { *m = SelectiveSlashingEvidence{} }
func (m *SelectiveSlashingEvidence) String() string { return proto.CompactTextString(m) }
func (*SelectiveSlashingEvidence) ProtoMessage()    {}
func (*SelectiveSlashingEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{11}
}
func (m *SelectiveSlashingEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SelectiveSlashingEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SelectiveSlashingEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SelectiveSlashingEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SelectiveSlashingEvidence.Merge(m, src)
}
func (m *SelectiveSlashingEvidence) XXX_Size() int {
	return m.Size()
}
func (m *SelectiveSlashingEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_SelectiveSlashingEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_SelectiveSlashingEvidence proto.InternalMessageInfo

func (m *SelectiveSlashingEvidence) GetRecoveredFpBtcSk() []byte {
	if m != nil {
		return m.RecoveredFpBtcSk
	}
	return nil
}

// InclusionProof proves the existence of tx on BTC blockchain
// including
// - the position of the tx on BTC blockchain
// - the Merkle proof that this tx is on the above position
type InclusionProof struct {
	// key is the position (txIdx, blockHash) of this tx on BTC blockchain
	Key *types1.TransactionKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// proof is the Merkle proof that this tx is included in the position in `key`
	Proof []byte `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *InclusionProof) Reset()         { *m = InclusionProof{} }
func (m *InclusionProof) String() string { return proto.CompactTextString(m) }
func (*InclusionProof) ProtoMessage()    {}
func (*InclusionProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{12}
}
func (m *InclusionProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InclusionProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InclusionProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InclusionProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InclusionProof.Merge(m, src)
}
func (m *InclusionProof) XXX_Size() int {
	return m.Size()
}
func (m *InclusionProof) XXX_DiscardUnknown() {
	xxx_messageInfo_InclusionProof.DiscardUnknown(m)
}

var xxx_messageInfo_InclusionProof proto.InternalMessageInfo

func (m *InclusionProof) GetKey() *types1.TransactionKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *InclusionProof) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

// LargestBtcReOrg stores the largest BTC reorg recorded
type LargestBtcReOrg struct {
	// BlockDiff is the difference of the block height of the BTC header Tip - the btc height
	// which it was rolled back
	BlockDiff uint32 `protobuf:"varint,1,opt,name=block_diff,json=blockDiff,proto3" json:"block_diff,omitempty"`
	// RollbackFrom is the latest BTC block header prior to rollback
	RollbackFrom *types2.BTCHeaderInfo `protobuf:"bytes,2,opt,name=rollback_from,json=rollbackFrom,proto3" json:"rollback_from,omitempty"`
	// RollbackTo is the BTC block header which we rollback to
	RollbackTo *types2.BTCHeaderInfo `protobuf:"bytes,3,opt,name=rollback_to,json=rollbackTo,proto3" json:"rollback_to,omitempty"`
}

func (m *LargestBtcReOrg) Reset()         { *m = LargestBtcReOrg{} }
func (m *LargestBtcReOrg) String() string { return proto.CompactTextString(m) }
func (*LargestBtcReOrg) ProtoMessage()    {}
func (*LargestBtcReOrg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{13}
}
func (m *LargestBtcReOrg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LargestBtcReOrg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LargestBtcReOrg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LargestBtcReOrg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LargestBtcReOrg.Merge(m, src)
}
func (m *LargestBtcReOrg) XXX_Size() int {
	return m.Size()
}
func (m *LargestBtcReOrg) XXX_DiscardUnknown() {
	xxx_messageInfo_LargestBtcReOrg.DiscardUnknown(m)
}

var xxx_messageInfo_LargestBtcReOrg proto.InternalMessageInfo

func (m *LargestBtcReOrg) GetBlockDiff() uint32 {
	if m != nil {
		return m.BlockDiff
	}
	return 0
}

func (m *LargestBtcReOrg) GetRollbackFrom() *types2.BTCHeaderInfo {
	if m != nil {
		return m.RollbackFrom
	}
	return nil
}

func (m *LargestBtcReOrg) GetRollbackTo() *types2.BTCHeaderInfo {
	if m != nil {
		return m.RollbackTo
	}
	return nil
}

// AdditionalStakerInfo is used when enabling multisig for btc staker
// NOTE: this structure doesn't contain original btc staker's signature, i.e., length of
// delegator_slashing_sigs and delegator_unbonding_slashing_sigs is M-1, and the length of
// staker_btc_pk_list is N-1
type AdditionalStakerInfo struct {
	// staker_btc_pk_list is the list of pubkeys of the btc staker that is using M-of-N multisig
	// length of staker_btc_pk_list is N-1
	StakerBtcPkList []github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey `protobuf:"bytes,1,rep,name=staker_btc_pk_list,json=stakerBtcPkList,proto3,customtype=github.com/babylonlabs-io/babylon/v4/types.BIP340PubKey" json:"staker_btc_pk_list,omitempty"`
	// staker_quorum is threshold of M-of-N multisig, which value itself represent M
	StakerQuorum uint32 `protobuf:"varint,2,opt,name=staker_quorum,json=stakerQuorum,proto3" json:"staker_quorum,omitempty"`
	// delegator_slashing_sigs is the (btc_pk, signature) pair on the slashing tx
	// by delegators (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the staking tx output.
	DelegatorSlashingSigs []*SignatureInfo `protobuf:"bytes,3,rep,name=delegator_slashing_sigs,json=delegatorSlashingSigs,proto3" json:"delegator_slashing_sigs,omitempty"`
	// delegator_unbonding_slashing_sigs is the (btc_pk, signature) pair on the slashing tx
	// by delegators (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the unbonding tx output.
	DelegatorUnbondingSlashingSigs []*SignatureInfo `protobuf:"bytes,4,rep,name=delegator_unbonding_slashing_sigs,json=delegatorUnbondingSlashingSigs,proto3" json:"delegator_unbonding_slashing_sigs,omitempty"`
}

func (m *AdditionalStakerInfo) Reset()         { *m = AdditionalStakerInfo{} }
func (m *AdditionalStakerInfo) String() string { return proto.CompactTextString(m) }
func (*AdditionalStakerInfo) ProtoMessage()    {}
func (*AdditionalStakerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{14}
}
func (m *AdditionalStakerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdditionalStakerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdditionalStakerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdditionalStakerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdditionalStakerInfo.Merge(m, src)
}
func (m *AdditionalStakerInfo) XXX_Size() int {
	return m.Size()
}
func (m *AdditionalStakerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AdditionalStakerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AdditionalStakerInfo proto.InternalMessageInfo

func (m *AdditionalStakerInfo) GetStakerQuorum() uint32 {
	if m != nil {
		return m.StakerQuorum
	}
	return 0
}

func (m *AdditionalStakerInfo) GetDelegatorSlashingSigs() []*SignatureInfo {
	if m != nil {
		return m.DelegatorSlashingSigs
	}
	return nil
}

func (m *AdditionalStakerInfo) GetDelegatorUnbondingSlashingSigs() []*SignatureInfo {
	if m != nil {
		return m.DelegatorUnbondingSlashingSigs
	}
	return nil
}

func init() {
	proto.RegisterEnum("babylon.btcstaking.v1.BTCDelegationStatus", BTCDelegationStatus_name, BTCDelegationStatus_value)
	proto.RegisterType((*FinalityProvider)(nil), "babylon.btcstaking.v1.FinalityProvider")
	proto.RegisterType((*CommissionInfo)(nil), "babylon.btcstaking.v1.CommissionInfo")
	proto.RegisterType((*FinalityProviderWithMeta)(nil), "babylon.btcstaking.v1.FinalityProviderWithMeta")
	proto.RegisterType((*BTCDelegation)(nil), "babylon.btcstaking.v1.BTCDelegation")
	proto.RegisterType((*StakeExpansion)(nil), "babylon.btcstaking.v1.StakeExpansion")
	proto.RegisterType((*DelegatorUnbondingInfo)(nil), "babylon.btcstaking.v1.DelegatorUnbondingInfo")
	proto.RegisterType((*BTCUndelegation)(nil), "babylon.btcstaking.v1.BTCUndelegation")
	proto.RegisterType((*BTCDelegatorDelegations)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegations")
	proto.RegisterType((*BTCDelegatorDelegationIndex)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegationIndex")
	proto.RegisterType((*SignatureInfo)(nil), "babylon.btcstaking.v1.SignatureInfo")
	proto.RegisterType((*CovenantAdaptorSignatures)(nil), "babylon.btcstaking.v1.CovenantAdaptorSignatures")
	proto.RegisterType((*SelectiveSlashingEvidence)(nil), "babylon.btcstaking.v1.SelectiveSlashingEvidence")
	proto.RegisterType((*InclusionProof)(nil), "babylon.btcstaking.v1.InclusionProof")
	proto.RegisterType((*LargestBtcReOrg)(nil), "babylon.btcstaking.v1.LargestBtcReOrg")
	proto.RegisterType((*AdditionalStakerInfo)(nil), "babylon.btcstaking.v1.AdditionalStakerInfo")
}

func init() {
	proto.RegisterFile("babylon/btcstaking/v1/btcstaking.proto", fileDescriptor_3851ae95ccfaf7db)
}

var fileDescriptor_3851ae95ccfaf7db = []byte{
	// 1874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x92, 0xd4, 0xbf, 0x47, 0x52, 0xa2, 0xc6, 0xb2, 0x4c, 0xcb, 0xa8, 0xa4, 0x30, 0x4e,
	0x20, 0xa4, 0x16, 0x69, 0x2b, 0x46, 0xd3, 0xba, 0xa8, 0x01, 0x51, 0xa4, 0x6a, 0x26, 0xb6, 0x44,
	0x2f, 0x69, 0xbb, 0x2d, 0x8a, 0x6e, 0x86, 0xbb, 0xc3, 0xe5, 0x96, 0xe4, 0xce, 0x76, 0x67, 0xc8,
	0x52, 0xdf, 0x22, 0x28, 0xda, 0x7b, 0x8f, 0x3d, 0x15, 0x3d, 0xe4, 0xd4, 0x4f, 0x10, 0xf4, 0x14,
	0xe4, 0xd2, 0xc2, 0x40, 0xd5, 0xc2, 0x3e, 0xa4, 0x1f, 0xa0, 0x1f, 0xa0, 0x98, 0x3f, 0x4b, 0x2e,
	0x15, 0xc9, 0x95, 0x6c, 0x5d, 0x08, 0xce, 0xfb, 0xf3, 0x7b, 0x33, 0xef, 0xfd, 0xde, 0x9b, 0x21,
	0xe1, 0xc3, 0x16, 0x6e, 0x1d, 0xf7, 0xa8, 0x5f, 0x6a, 0x71, 0x9b, 0x71, 0xdc, 0xf5, 0x7c, 0xb7,
	0x34, 0xbc, 0x17, 0x5b, 0x15, 0x83, 0x90, 0x72, 0x8a, 0xae, 0x6b, 0xbb, 0x62, 0x4c, 0x33, 0xbc,
	0xb7, 0xbe, 0xea, 0x52, 0x97, 0x4a, 0x8b, 0x92, 0xf8, 0xa6, 0x8c, 0xd7, 0x6f, 0xda, 0x94, 0xf5,
	0x29, 0xb3, 0x94, 0x42, 0x2d, 0xb4, 0xea, 0xb6, 0x5a, 0x95, 0x26, 0xb1, 0x5a, 0x84, 0xe3, 0x7b,
	0xa5, 0xa9, 0x68, 0xeb, 0x9b, 0x67, 0xef, 0x2a, 0xa0, 0x81, 0x36, 0xb8, 0x13, 0x33, 0xb0, 0x3b,
	0xc4, 0xee, 0x06, 0xd4, 0xf3, 0xb9, 0xde, 0xf9, 0x44, 0xa0, 0xad, 0x8b, 0x31, 0xeb, 0x9e, 0xe7,
	0x76, 0xc4, 0x27, 0x19, 0x9b, 0xc7, 0x24, 0xda, 0x7e, 0x05, 0xf7, 0x3d, 0x9f, 0x96, 0xe4, 0x67,
	0xb4, 0x23, 0x97, 0x52, 0xb7, 0x47, 0x4a, 0x72, 0xd5, 0x1a, 0xb4, 0x4b, 0xdc, 0xeb, 0x13, 0xc6,
	0x71, 0x5f, 0xef, 0xa8, 0xf0, 0x6d, 0x0a, 0x72, 0x07, 0x9e, 0x8f, 0x7b, 0x1e, 0x3f, 0xae, 0x87,
	0x74, 0xe8, 0x39, 0x24, 0x44, 0x77, 0x20, 0x85, 0x1d, 0x27, 0xcc, 0x1b, 0x5b, 0xc6, 0xf6, 0x62,
	0x39, 0xff, 0xcd, 0x97, 0x3b, 0xab, 0x3a, 0x1b, 0x7b, 0x8e, 0x13, 0x12, 0xc6, 0x1a, 0x3c, 0xf4,
	0x7c, 0xd7, 0x94, 0x56, 0xa8, 0x0a, 0x69, 0x87, 0x30, 0x3b, 0xf4, 0x02, 0xee, 0x51, 0x3f, 0x9f,
	0xd8, 0x32, 0xb6, 0xd3, 0xbb, 0xef, 0x17, 0xb5, 0xc7, 0x24, 0xeb, 0x32, 0x63, 0xc5, 0xca, 0xc4,
	0xd4, 0x8c, 0xfb, 0xa1, 0x27, 0x00, 0x36, 0xed, 0xf7, 0x3d, 0xc6, 0x04, 0x4a, 0x52, 0x86, 0xde,
	0x79, 0x79, 0xb2, 0x79, 0x4b, 0x01, 0x31, 0xa7, 0x5b, 0xf4, 0x68, 0xa9, 0x8f, 0x79, 0xa7, 0xf8,
	0x98, 0xb8, 0xd8, 0x3e, 0xae, 0x10, 0xfb, 0x9b, 0x2f, 0x77, 0x40, 0xc7, 0xa9, 0x10, 0xdb, 0x8c,
	0x01, 0x20, 0x13, 0xe6, 0x5a, 0xdc, 0xb6, 0x82, 0x6e, 0x3e, 0xb5, 0x65, 0x6c, 0x67, 0xca, 0x3f,
	0x7e, 0x79, 0xb2, 0xf9, 0x89, 0xeb, 0xf1, 0xce, 0xa0, 0x55, 0xb4, 0x69, 0xbf, 0xa4, 0x73, 0xdb,
	0xc3, 0x2d, 0xb6, 0xe3, 0xd1, 0x68, 0x59, 0x1a, 0xde, 0x2f, 0xf1, 0xe3, 0x80, 0xb0, 0x62, 0xb9,
	0x56, 0xff, 0xf8, 0xfe, 0xdd, 0xfa, 0xa0, 0xf5, 0x19, 0x39, 0x36, 0x67, 0x5b, 0xdc, 0xae, 0x77,
	0xd1, 0x4f, 0x20, 0x19, 0xd0, 0x20, 0x3f, 0x2b, 0x4f, 0xf8, 0xfd, 0xe2, 0x99, 0xdc, 0x2a, 0xd6,
	0x43, 0x4a, 0xdb, 0x47, 0xed, 0x3a, 0x65, 0x8c, 0xc8, 0xad, 0x94, 0x9b, 0xfb, 0xa6, 0xf0, 0x43,
	0xf7, 0x61, 0x8d, 0xf5, 0x30, 0xeb, 0x10, 0xc7, 0xd2, 0xae, 0x56, 0x87, 0x88, 0x2a, 0xe6, 0xe7,
	0xb6, 0x8c, 0xed, 0x94, 0xb9, 0xaa, 0xb5, 0x65, 0xa5, 0x7c, 0x24, 0x75, 0xe8, 0x0e, 0xa0, 0xb1,
	0x17, 0xb7, 0x23, 0x8f, 0xf9, 0x2d, 0x63, 0x3b, 0x6b, 0xe6, 0x22, 0x0f, 0x6e, 0x6b, 0xeb, 0x35,
	0x98, 0xfb, 0x35, 0xf6, 0x7a, 0xc4, 0xc9, 0x2f, 0x6c, 0x19, 0xdb, 0x0b, 0xa6, 0x5e, 0xa1, 0xbb,
	0xb0, 0xda, 0xf1, 0xdc, 0x0e, 0x61, 0xdc, 0x1a, 0x52, 0x4e, 0x9c, 0x08, 0x67, 0x51, 0xe2, 0x20,
	0xad, 0x7b, 0x2e, 0x54, 0x1a, 0xe9, 0x10, 0x96, 0x27, 0xe9, 0xb4, 0x3c, 0xbf, 0x4d, 0xf3, 0x69,
	0x79, 0xf0, 0x0f, 0xce, 0x39, 0xf8, 0xfe, 0xd8, 0xba, 0xe6, 0xb7, 0xa9, 0xb9, 0x64, 0x4f, 0xad,
	0x0b, 0x7f, 0x48, 0xc0, 0xd2, 0xb4, 0x09, 0x7a, 0x0a, 0x0b, 0x7d, 0x3c, 0xb2, 0x42, 0xcc, 0x89,
	0xe6, 0xda, 0x0f, 0xbe, 0x3a, 0xd9, 0x9c, 0xb9, 0x54, 0xd1, 0xff, 0xf4, 0xed, 0x5f, 0x3e, 0x32,
	0xcc, 0xf9, 0x3e, 0x1e, 0x99, 0x98, 0x13, 0xf4, 0x2b, 0x58, 0x16, 0x90, 0x76, 0x07, 0xfb, 0x2e,
	0x51, 0xc8, 0x89, 0x77, 0x42, 0xce, 0xf6, 0xf1, 0x68, 0x5f, 0xa2, 0x49, 0xfc, 0x4f, 0x21, 0x3d,
	0x08, 0x1c, 0xcc, 0x89, 0x25, 0x3a, 0x49, 0xd2, 0x34, 0xbd, 0xbb, 0x5e, 0x54, 0x6d, 0x56, 0x8c,
	0xda, 0xac, 0xd8, 0x8c, 0xda, 0xac, 0x9c, 0x15, 0x71, 0xbf, 0xf8, 0xd7, 0xa6, 0xa1, 0xe0, 0x40,
	0x79, 0x0b, 0xfd, 0x83, 0xd4, 0x7f, 0xfe, 0xb8, 0x69, 0x14, 0xfe, 0x9e, 0x80, 0xfc, 0xe9, 0x0e,
	0x7c, 0xe1, 0xf1, 0xce, 0x13, 0xc2, 0x71, 0x8c, 0xc5, 0xc6, 0x95, 0xb1, 0x78, 0x0d, 0xe6, 0x74,
	0xf1, 0x13, 0x92, 0x76, 0x7a, 0x85, 0xde, 0x83, 0xcc, 0x90, 0x72, 0xcf, 0x77, 0xad, 0x80, 0xfe,
	0x96, 0x84, 0xf2, 0x6c, 0x29, 0x33, 0xad, 0x64, 0x75, 0x21, 0x7a, 0x03, 0x83, 0x53, 0x97, 0x66,
	0xf0, 0xec, 0xff, 0x65, 0xf0, 0xdc, 0x85, 0x18, 0x3c, 0x7f, 0x1e, 0x83, 0x0b, 0x27, 0x0b, 0x90,
	0x2d, 0x37, 0xf7, 0x2b, 0xa4, 0x47, 0x5c, 0x2c, 0x67, 0xcc, 0x8f, 0x20, 0x2d, 0x08, 0x4b, 0x42,
	0xeb, 0x42, 0xf3, 0x0d, 0x94, 0xb1, 0x10, 0xc6, 0x2a, 0x91, 0xb8, 0xea, 0x79, 0x92, 0x7c, 0xcb,
	0x79, 0xf2, 0x39, 0x2c, 0xb5, 0x03, 0x4b, 0xed, 0xca, 0xea, 0x79, 0x4c, 0x54, 0x21, 0xf9, 0xae,
	0x5b, 0x4b, 0xb7, 0x83, 0xb2, 0xd8, 0xdc, 0x63, 0x8f, 0x49, 0x4a, 0xe8, 0x9d, 0x28, 0xba, 0xab,
	0x9a, 0xa5, 0xb5, 0x4c, 0x90, 0x58, 0x9b, 0x84, 0x3c, 0x3e, 0xca, 0x94, 0x49, 0xc8, 0x75, 0x45,
	0xbf, 0x07, 0x40, 0xfc, 0x53, 0xf5, 0x5a, 0x24, 0x7e, 0x34, 0x68, 0x6e, 0xc1, 0x22, 0xa7, 0x1c,
	0xf7, 0x2c, 0x86, 0xb9, 0x9c, 0x5a, 0x29, 0x73, 0x41, 0x0a, 0x1a, 0x58, 0xfa, 0x8e, 0x77, 0x30,
	0x92, 0xd3, 0x2a, 0x63, 0x2e, 0x46, 0xf1, 0x47, 0x92, 0x5a, 0x5a, 0x4d, 0x07, 0x3c, 0x18, 0x70,
	0xcb, 0x73, 0x46, 0x79, 0xd0, 0xd4, 0x52, 0x9a, 0x23, 0xa9, 0xa8, 0x39, 0x23, 0xb4, 0x0b, 0x69,
	0x49, 0x37, 0x8d, 0x96, 0x96, 0x85, 0x5c, 0x79, 0x79, 0xb2, 0x29, 0x68, 0xd2, 0xd0, 0x9a, 0xe6,
	0xc8, 0x04, 0x36, 0xfe, 0x8e, 0x6c, 0xc8, 0x3a, 0x8a, 0x40, 0x34, 0xb4, 0x98, 0xe7, 0xe6, 0x33,
	0xd2, 0xeb, 0xe1, 0xcb, 0x93, 0xcd, 0x07, 0x97, 0xce, 0x71, 0xc3, 0x73, 0x7d, 0xcc, 0x07, 0x21,
	0x31, 0x33, 0x63, 0xd0, 0x86, 0xe7, 0xa2, 0x67, 0x90, 0xb5, 0xe9, 0x90, 0xf8, 0xd8, 0xe7, 0x22,
	0x06, 0xcb, 0x67, 0xb7, 0x92, 0xdb, 0xe9, 0xdd, 0xbb, 0xe7, 0x4e, 0x5a, 0x65, 0xbb, 0xe7, 0xe0,
	0x40, 0x21, 0x28, 0x54, 0x66, 0x66, 0x22, 0x98, 0x86, 0xe7, 0x32, 0xf4, 0x01, 0x2c, 0x0d, 0xfc,
	0x16, 0xf5, 0x9d, 0x71, 0x01, 0x97, 0x64, 0x66, 0xb2, 0x63, 0xa9, 0x2c, 0xe1, 0x53, 0xc8, 0x09,
	0x12, 0x0d, 0x7c, 0x67, 0xdc, 0x29, 0xf9, 0x65, 0xc9, 0xc9, 0x0f, 0xcf, 0xd9, 0x40, 0xb9, 0xb9,
	0xff, 0x2c, 0x66, 0x6d, 0x2e, 0xb7, 0xb8, 0x1d, 0x17, 0x88, 0xc8, 0x01, 0x0e, 0x71, 0x9f, 0x59,
	0x43, 0x12, 0xca, 0x0b, 0x3d, 0xa7, 0x22, 0x2b, 0xe9, 0x73, 0x25, 0x44, 0xb7, 0x61, 0x49, 0x44,
	0xe6, 0x5e, 0x10, 0xb1, 0x63, 0x45, 0x9a, 0x65, 0x5a, 0xdc, 0x6e, 0x7a, 0x81, 0x26, 0xc8, 0x43,
	0x98, 0x67, 0xbc, 0x6b, 0x91, 0x51, 0x90, 0x47, 0x6f, 0xbc, 0x81, 0x1a, 0xa2, 0x5d, 0xab, 0xa3,
	0x00, 0xfb, 0x02, 0xdd, 0x9c, 0x63, 0xbc, 0x5b, 0x1d, 0x05, 0xe8, 0x05, 0xac, 0x90, 0x11, 0x0f,
	0xb1, 0xa5, 0x7b, 0x5f, 0xde, 0x65, 0xd7, 0xde, 0xd8, 0x74, 0x7b, 0x8e, 0xe3, 0x89, 0x83, 0xe0,
	0x9e, 0xc4, 0x0c, 0xe5, 0x8d, 0xb6, 0x2c, 0x51, 0x26, 0x82, 0xc2, 0x3f, 0x0d, 0x58, 0x9a, 0x8e,
	0x89, 0x3e, 0x81, 0x7c, 0x10, 0x92, 0xa1, 0x47, 0x07, 0xcc, 0x9a, 0x10, 0xd7, 0xea, 0x60, 0xd6,
	0x51, 0x23, 0xdc, 0xbc, 0x1e, 0xe9, 0x1b, 0x11, 0x8b, 0x1f, 0x61, 0xd6, 0x41, 0x25, 0x58, 0xa5,
	0xbc, 0x43, 0x42, 0xab, 0x3d, 0xd0, 0xf5, 0x1a, 0x09, 0x4a, 0xab, 0x69, 0x63, 0xae, 0x48, 0xdd,
	0x81, 0x52, 0x35, 0x47, 0x47, 0x03, 0x8e, 0x30, 0xac, 0xc7, 0x22, 0x75, 0xad, 0x69, 0x02, 0x25,
	0x25, 0x81, 0x6e, 0x9f, 0x97, 0xa8, 0x88, 0x31, 0xf2, 0x5c, 0x37, 0x26, 0x3b, 0xea, 0xee, 0xc7,
	0xf8, 0x53, 0x78, 0x08, 0x6b, 0x95, 0x88, 0xa6, 0xcf, 0x22, 0xca, 0xc8, 0x9b, 0xfb, 0x36, 0x2c,
	0xb1, 0x40, 0x34, 0xb5, 0x4c, 0xa9, 0x68, 0x26, 0x75, 0xb8, 0x8c, 0x94, 0xca, 0x9c, 0x34, 0x47,
	0x85, 0xdf, 0xa7, 0x60, 0xf9, 0x14, 0x55, 0xc4, 0xbc, 0x88, 0x71, 0x32, 0xf2, 0x4b, 0x4f, 0x18,
	0xf9, 0x9d, 0x36, 0x4d, 0x5c, 0xa4, 0x4d, 0x39, 0xac, 0xc5, 0xda, 0x34, 0xf2, 0x16, 0xfd, 0x9a,
	0xbc, 0x92, 0x7e, 0x5d, 0x9d, 0xf4, 0xab, 0x06, 0x17, 0x7d, 0xdb, 0x86, 0xb5, 0x49, 0xda, 0x63,
	0x41, 0x99, 0x9c, 0xc4, 0x6f, 0xd3, 0xc0, 0xab, 0xe3, 0x06, 0x9e, 0x84, 0x61, 0xc8, 0x86, 0x5b,
	0xe3, 0x38, 0x93, 0xec, 0x31, 0xcf, 0x55, 0x63, 0x7f, 0xf6, 0x12, 0xc5, 0xce, 0x47, 0x40, 0xe3,
	0x82, 0x36, 0x3c, 0x57, 0x0e, 0x7b, 0x17, 0xf2, 0x93, 0x14, 0x4e, 0xa2, 0xc8, 0x6e, 0x99, 0x93,
	0xdd, 0xb2, 0x73, 0x4e, 0x84, 0xb3, 0x49, 0x62, 0x4e, 0x2a, 0x32, 0x25, 0x2f, 0x34, 0xe0, 0xc6,
	0xe4, 0x5a, 0xa6, 0xe1, 0xe4, 0x7e, 0x66, 0xe8, 0x87, 0x90, 0x72, 0x48, 0x8f, 0xe5, 0x8d, 0x37,
	0x9e, 0x68, 0xea, 0x52, 0x37, 0xa5, 0x47, 0xe1, 0x10, 0x6e, 0x9d, 0x0d, 0x5a, 0xf3, 0x1d, 0x32,
	0x12, 0xed, 0x75, 0xaa, 0x1d, 0x55, 0xea, 0x44, 0xa0, 0x8c, 0xb9, 0xc2, 0xe2, 0xbd, 0x28, 0xb2,
	0x51, 0xf8, 0xb3, 0x01, 0xd9, 0xa9, 0xcc, 0xa1, 0xcf, 0x20, 0x71, 0x35, 0xef, 0xb0, 0x44, 0xd0,
	0x45, 0x75, 0x48, 0x0a, 0x72, 0x26, 0xae, 0x84, 0x9c, 0x02, 0xaa, 0xf0, 0x3b, 0x03, 0x6e, 0x9e,
	0xcb, 0x2b, 0xf1, 0x7c, 0xb1, 0xe9, 0xf0, 0xaa, 0x1e, 0x92, 0x36, 0x1d, 0xd6, 0xbb, 0xa2, 0x95,
	0xb1, 0x0a, 0xa4, 0x38, 0x9f, 0x90, 0xb9, 0x4c, 0xe3, 0x71, 0x70, 0x56, 0xf8, 0xab, 0x01, 0x37,
	0x1b, 0xa4, 0x47, 0x6c, 0xee, 0x0d, 0x49, 0x44, 0xe9, 0xaa, 0x78, 0xe3, 0xfa, 0x36, 0x41, 0x2f,
	0x60, 0x71, 0xfc, 0x80, 0xb9, 0x8a, 0x67, 0xd5, 0xbc, 0x7e, 0xbb, 0xa0, 0x1d, 0xb8, 0x16, 0x12,
	0x41, 0xf4, 0x90, 0x38, 0x96, 0x0e, 0xc1, 0xba, 0x6a, 0x14, 0x98, 0xb9, 0xb1, 0xea, 0x40, 0x98,
	0x37, 0xba, 0x9f, 0xa6, 0x16, 0x8c, 0x5c, 0xc2, 0x5c, 0x3e, 0x45, 0x90, 0x42, 0x0b, 0x96, 0x6a,
	0xbe, 0xdd, 0x1b, 0x88, 0xc1, 0x2e, 0x5f, 0x61, 0xe8, 0x01, 0x24, 0xbb, 0xe4, 0x58, 0xa6, 0x30,
	0xbd, 0xbb, 0x1d, 0x67, 0x67, 0xec, 0xc7, 0xfb, 0xf0, 0x5e, 0xb1, 0x19, 0x62, 0x9f, 0x61, 0x5b,
	0xd0, 0x4f, 0xec, 0x4b, 0x38, 0xa1, 0x55, 0x98, 0x0d, 0x04, 0x88, 0x9e, 0xe8, 0x6a, 0x51, 0xf8,
	0x9b, 0x01, 0xcb, 0x8f, 0x71, 0xe8, 0x12, 0xc6, 0xcb, 0xdc, 0x36, 0xc9, 0x51, 0xe8, 0x8a, 0x37,
	0x4f, 0xab, 0x47, 0xed, 0xae, 0xe5, 0x78, 0xed, 0xb6, 0x0c, 0x96, 0x35, 0x17, 0xa5, 0xa4, 0xe2,
	0xb5, 0xdb, 0xe8, 0x09, 0x64, 0x43, 0xda, 0xeb, 0xb5, 0xb0, 0xdd, 0xb5, 0xda, 0x21, 0xed, 0xeb,
	0x5f, 0xdc, 0x53, 0xdb, 0x89, 0xff, 0x39, 0xa0, 0x1a, 0xe6, 0x11, 0xc1, 0x8e, 0xbe, 0xc7, 0x32,
	0x91, 0xfb, 0x41, 0x48, 0xfb, 0xa8, 0x06, 0xe9, 0x31, 0x1c, 0xa7, 0xfa, 0x31, 0x7a, 0x71, 0x30,
	0x88, 0x9c, 0x9b, 0xb4, 0xf0, 0xdf, 0x04, 0xac, 0x9e, 0x75, 0x73, 0xa2, 0x8e, 0x7a, 0xa6, 0x91,
	0x70, 0xea, 0xb5, 0x6a, 0xbc, 0xfb, 0x6b, 0x75, 0x59, 0xc1, 0x4e, 0x5e, 0xac, 0xef, 0x43, 0x56,
	0x47, 0xfa, 0xcd, 0x80, 0x86, 0x03, 0x95, 0x9c, 0xac, 0x99, 0x51, 0xc2, 0xa7, 0x52, 0x86, 0x7e,
	0x09, 0x37, 0xce, 0xbe, 0x2c, 0x2e, 0x77, 0x6f, 0x5e, 0x3f, 0xeb, 0x4e, 0x60, 0x88, 0xc2, 0x7b,
	0x67, 0xcd, 0xd1, 0xb3, 0xee, 0x87, 0x8b, 0xc5, 0xd9, 0xf8, 0xee, 0x1c, 0x8d, 0x07, 0xfc, 0xe8,
	0x73, 0xb8, 0x36, 0x35, 0x11, 0x1b, 0x1c, 0xf3, 0x01, 0x43, 0x69, 0x98, 0xaf, 0x57, 0x0f, 0x2b,
	0xb5, 0xc3, 0x9f, 0xe6, 0x66, 0x50, 0x06, 0x16, 0x9e, 0x57, 0xcd, 0xda, 0x41, 0xad, 0x5a, 0xc9,
	0x19, 0x08, 0x60, 0x6e, 0x6f, 0xbf, 0x59, 0x7b, 0x5e, 0xcd, 0x25, 0x84, 0xe6, 0xd9, 0x61, 0xf9,
	0xe8, 0xb0, 0x52, 0xad, 0xe4, 0x92, 0xc2, 0xa9, 0xfa, 0xb3, 0x7a, 0xcd, 0xac, 0x56, 0x72, 0x29,
	0x34, 0x0f, 0xc9, 0xbd, 0xc3, 0x9f, 0xe7, 0x66, 0xcb, 0x4f, 0xbf, 0x7a, 0xb5, 0x61, 0x7c, 0xfd,
	0x6a, 0xc3, 0xf8, 0xf7, 0xab, 0x0d, 0xe3, 0x8b, 0xd7, 0x1b, 0x33, 0x5f, 0xbf, 0xde, 0x98, 0xf9,
	0xc7, 0xeb, 0x8d, 0x99, 0x5f, 0x5c, 0xac, 0x72, 0xa3, 0xf8, 0x3f, 0x62, 0xb2, 0x8c, 0xad, 0x39,
	0xf9, 0x5b, 0xf9, 0xe3, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x49, 0x66, 0xea, 0x76, 0xca, 0x13,
	0x00, 0x00,
}

func (this *CommissionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CommissionInfo)
	if !ok {
		that2, ok := that.(CommissionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MaxRate.Equal(that1.MaxRate) {
		return false
	}
	if !this.MaxChangeRate.Equal(that1.MaxChangeRate) {
		return false
	}
	if !this.UpdateTime.Equal(that1.UpdateTime) {
		return false
	}
	return true
}
func (m *FinalityProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalityProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalityProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommissionInfo != nil {
		{
			size, err := m.CommissionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.HighestVotedHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.HighestVotedHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Commission != nil {
		{
			size := m.Commission.Size()
			i -= size
			if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommissionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommissionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommissionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdateTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdateTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintBtcstaking(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1a
	{
		size := m.MaxChangeRate.Size()
		i -= size
		if _, err := m.MaxChangeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBtcstaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.MaxRate.Size()
		i -= size
		if _, err := m.MaxRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBtcstaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FinalityProviderWithMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalityProviderWithMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalityProviderWithMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighestVotedHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.HighestVotedHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.VotingPower != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtraStakerInfo != nil {
		{
			size, err := m.ExtraStakerInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.StkExp != nil {
		{
			size, err := m.StkExp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.BtcTipHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.BtcTipHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ParamsVersion != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.ParamsVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.BtcUndelegation != nil {
		{
			size, err := m.BtcUndelegation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.UnbondingTime != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.UnbondingTime))
		i--
		dAtA[i] = 0x70
	}
	if len(m.CovenantSigs) > 0 {
		for iNdEx := len(m.CovenantSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.DelegatorSig != nil {
		{
			size := m.DelegatorSig.Size()
			i -= size
			if _, err := m.DelegatorSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.StakingOutputIdx != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StakingOutputIdx))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StakingTx) > 0 {
		i -= len(m.StakingTx)
		copy(dAtA[i:], m.StakingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTx)))
		i--
		dAtA[i] = 0x4a
	}
	if m.TotalSat != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.TotalSat))
		i--
		dAtA[i] = 0x40
	}
	if m.EndHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.StartHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.StakingTime != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StakingTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FpBtcPkList) > 0 {
		for iNdEx := len(m.FpBtcPkList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.FpBtcPkList[iNdEx].Size()
				i -= size
				if _, err := m.FpBtcPkList[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddr) > 0 {
		i -= len(m.StakerAddr)
		copy(dAtA[i:], m.StakerAddr)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakerAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakeExpansion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakeExpansion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakeExpansion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreviousStkCovenantSigs) > 0 {
		for iNdEx := len(m.PreviousStkCovenantSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PreviousStkCovenantSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OtherFundingTxOut) > 0 {
		i -= len(m.OtherFundingTxOut)
		copy(dAtA[i:], m.OtherFundingTxOut)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.OtherFundingTxOut)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousStakingTxHash) > 0 {
		i -= len(m.PreviousStakingTxHash)
		copy(dAtA[i:], m.PreviousStakingTxHash)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.PreviousStakingTxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorUnbondingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorUnbondingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorUnbondingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpendStakeTx) > 0 {
		i -= len(m.SpendStakeTx)
		copy(dAtA[i:], m.SpendStakeTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.SpendStakeTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorUnbondingInfo != nil {
		{
			size, err := m.DelegatorUnbondingInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CovenantUnbondingSigList) > 0 {
		for iNdEx := len(m.CovenantUnbondingSigList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantUnbondingSigList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CovenantSlashingSigs) > 0 {
		for iNdEx := len(m.CovenantSlashingSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantSlashingSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DelegatorSlashingSig != nil {
		{
			size := m.DelegatorSlashingSig.Size()
			i -= size
			if _, err := m.DelegatorSlashingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UnbondingTx) > 0 {
		i -= len(m.UnbondingTx)
		copy(dAtA[i:], m.UnbondingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.UnbondingTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for iNdEx := len(m.Dels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegationIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegationIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegationIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakingTxHashList) > 0 {
		for iNdEx := len(m.StakingTxHashList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StakingTxHashList[iNdEx])
			copy(dAtA[i:], m.StakingTxHashList[iNdEx])
			i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTxHashList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignatureInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sig != nil {
		{
			size := m.Sig.Size()
			i -= size
			if _, err := m.Sig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pk != nil {
		{
			size := m.Pk.Size()
			i -= size
			if _, err := m.Pk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CovenantAdaptorSignatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CovenantAdaptorSignatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CovenantAdaptorSignatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdaptorSigs) > 0 {
		for iNdEx := len(m.AdaptorSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AdaptorSigs[iNdEx])
			copy(dAtA[i:], m.AdaptorSigs[iNdEx])
			i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.AdaptorSigs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CovPk != nil {
		{
			size := m.CovPk.Size()
			i -= size
			if _, err := m.CovPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SelectiveSlashingEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelectiveSlashingEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SelectiveSlashingEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecoveredFpBtcSk) > 0 {
		i -= len(m.RecoveredFpBtcSk)
		copy(dAtA[i:], m.RecoveredFpBtcSk)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.RecoveredFpBtcSk)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FpBtcPk != nil {
		{
			size := m.FpBtcPk.Size()
			i -= size
			if _, err := m.FpBtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *InclusionProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InclusionProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InclusionProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LargestBtcReOrg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LargestBtcReOrg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LargestBtcReOrg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RollbackTo != nil {
		{
			size, err := m.RollbackTo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RollbackFrom != nil {
		{
			size, err := m.RollbackFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BlockDiff != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.BlockDiff))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdditionalStakerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdditionalStakerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdditionalStakerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorUnbondingSlashingSigs) > 0 {
		for iNdEx := len(m.DelegatorUnbondingSlashingSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DelegatorUnbondingSlashingSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DelegatorSlashingSigs) > 0 {
		for iNdEx := len(m.DelegatorSlashingSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DelegatorSlashingSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.StakerQuorum != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StakerQuorum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.StakerBtcPkList) > 0 {
		for iNdEx := len(m.StakerBtcPkList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.StakerBtcPkList[iNdEx].Size()
				i -= size
				if _, err := m.StakerBtcPkList[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBtcstaking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBtcstaking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FinalityProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Commission != nil {
		l = m.Commission.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	if m.Jailed {
		n += 2
	}
	if m.HighestVotedHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.HighestVotedHeight))
	}
	if m.CommissionInfo != nil {
		l = m.CommissionInfo.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *CommissionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MaxRate.Size()
	n += 1 + l + sovBtcstaking(uint64(l))
	l = m.MaxChangeRate.Size()
	n += 1 + l + sovBtcstaking(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdateTime)
	n += 1 + l + sovBtcstaking(uint64(l))
	return n
}

func (m *FinalityProviderWithMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovBtcstaking(uint64(m.Height))
	}
	if m.VotingPower != 0 {
		n += 1 + sovBtcstaking(uint64(m.VotingPower))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	if m.Jailed {
		n += 2
	}
	if m.HighestVotedHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.HighestVotedHeight))
	}
	return n
}

func (m *BTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddr)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.FpBtcPkList) > 0 {
		for _, e := range m.FpBtcPkList {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.StakingTime != 0 {
		n += 1 + sovBtcstaking(uint64(m.StakingTime))
	}
	if m.StartHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.EndHeight))
	}
	if m.TotalSat != 0 {
		n += 1 + sovBtcstaking(uint64(m.TotalSat))
	}
	l = len(m.StakingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.StakingOutputIdx != 0 {
		n += 1 + sovBtcstaking(uint64(m.StakingOutputIdx))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSig != nil {
		l = m.DelegatorSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.CovenantSigs) > 0 {
		for _, e := range m.CovenantSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.UnbondingTime != 0 {
		n += 1 + sovBtcstaking(uint64(m.UnbondingTime))
	}
	if m.BtcUndelegation != nil {
		l = m.BtcUndelegation.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.ParamsVersion != 0 {
		n += 2 + sovBtcstaking(uint64(m.ParamsVersion))
	}
	if m.BtcTipHeight != 0 {
		n += 2 + sovBtcstaking(uint64(m.BtcTipHeight))
	}
	if m.StkExp != nil {
		l = m.StkExp.Size()
		n += 2 + l + sovBtcstaking(uint64(l))
	}
	if m.ExtraStakerInfo != nil {
		l = m.ExtraStakerInfo.Size()
		n += 2 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *StakeExpansion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousStakingTxHash)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.OtherFundingTxOut)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.PreviousStkCovenantSigs) > 0 {
		for _, e := range m.PreviousStkCovenantSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *DelegatorUnbondingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpendStakeTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCUndelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnbondingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSlashingSig != nil {
		l = m.DelegatorSlashingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.CovenantSlashingSigs) > 0 {
		for _, e := range m.CovenantSlashingSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if len(m.CovenantUnbondingSigList) > 0 {
		for _, e := range m.CovenantUnbondingSigList {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.DelegatorUnbondingInfo != nil {
		l = m.DelegatorUnbondingInfo.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCDelegatorDelegations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for _, e := range m.Dels {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *BTCDelegatorDelegationIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StakingTxHashList) > 0 {
		for _, b := range m.StakingTxHashList {
			l = len(b)
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *SignatureInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pk != nil {
		l = m.Pk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Sig != nil {
		l = m.Sig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *CovenantAdaptorSignatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CovPk != nil {
		l = m.CovPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.AdaptorSigs) > 0 {
		for _, b := range m.AdaptorSigs {
			l = len(b)
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *SelectiveSlashingEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FpBtcPk != nil {
		l = m.FpBtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.RecoveredFpBtcSk)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *InclusionProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *LargestBtcReOrg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockDiff != 0 {
		n += 1 + sovBtcstaking(uint64(m.BlockDiff))
	}
	if m.RollbackFrom != nil {
		l = m.RollbackFrom.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.RollbackTo != nil {
		l = m.RollbackTo.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *AdditionalStakerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StakerBtcPkList) > 0 {
		for _, e := range m.StakerBtcPkList {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.StakerQuorum != 0 {
		n += 1 + sovBtcstaking(uint64(m.StakerQuorum))
	}
	if len(m.DelegatorSlashingSigs) > 0 {
		for _, e := range m.DelegatorSlashingSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if len(m.DelegatorUnbondingSlashingSigs) > 0 {
		for _, e := range m.DelegatorUnbondingSlashingSigs {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func sovBtcstaking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBtcstaking(x uint64) (n int) {
	return sovBtcstaking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FinalityProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalityProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalityProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &types.Description{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.Commission = &v
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossessionBTC{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestVotedHeight", wireType)
			}
			m.HighestVotedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestVotedHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommissionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommissionInfo == nil {
				m.CommissionInfo = &CommissionInfo{}
			}
			if err := m.CommissionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommissionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommissionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommissionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChangeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxChangeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalityProviderWithMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalityProviderWithMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalityProviderWithMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestVotedHeight", wireType)
			}
			m.HighestVotedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestVotedHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossessionBTC{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpBtcPkList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.FpBtcPkList = append(m.FpBtcPkList, v)
			if err := m.FpBtcPkList[len(m.FpBtcPkList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTime", wireType)
			}
			m.StakingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			m.TotalSat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTx = append(m.StakingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.StakingTx == nil {
				m.StakingTx = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingOutputIdx", wireType)
			}
			m.StakingOutputIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingOutputIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340Signature
			m.DelegatorSig = &v
			if err := m.DelegatorSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantSigs = append(m.CovenantSigs, &CovenantAdaptorSignatures{})
			if err := m.CovenantSigs[len(m.CovenantSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTime", wireType)
			}
			m.UnbondingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcUndelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BtcUndelegation == nil {
				m.BtcUndelegation = &BTCUndelegation{}
			}
			if err := m.BtcUndelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsVersion", wireType)
			}
			m.ParamsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamsVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcTipHeight", wireType)
			}
			m.BtcTipHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BtcTipHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StkExp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StkExp == nil {
				m.StkExp = &StakeExpansion{}
			}
			if err := m.StkExp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStakerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraStakerInfo == nil {
				m.ExtraStakerInfo = &AdditionalStakerInfo{}
			}
			if err := m.ExtraStakerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakeExpansion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakeExpansion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakeExpansion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousStakingTxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousStakingTxHash = append(m.PreviousStakingTxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousStakingTxHash == nil {
				m.PreviousStakingTxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherFundingTxOut", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherFundingTxOut = append(m.OtherFundingTxOut[:0], dAtA[iNdEx:postIndex]...)
			if m.OtherFundingTxOut == nil {
				m.OtherFundingTxOut = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousStkCovenantSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousStkCovenantSigs = append(m.PreviousStkCovenantSigs, &SignatureInfo{})
			if err := m.PreviousStkCovenantSigs[len(m.PreviousStkCovenantSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorUnbondingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorUnbondingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorUnbondingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendStakeTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpendStakeTx = append(m.SpendStakeTx[:0], dAtA[iNdEx:postIndex]...)
			if m.SpendStakeTx == nil {
				m.SpendStakeTx = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondingTx = append(m.UnbondingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.UnbondingTx == nil {
				m.UnbondingTx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340Signature
			m.DelegatorSlashingSig = &v
			if err := m.DelegatorSlashingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSlashingSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantSlashingSigs = append(m.CovenantSlashingSigs, &CovenantAdaptorSignatures{})
			if err := m.CovenantSlashingSigs[len(m.CovenantSlashingSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantUnbondingSigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantUnbondingSigList = append(m.CovenantUnbondingSigList, &SignatureInfo{})
			if err := m.CovenantUnbondingSigList[len(m.CovenantUnbondingSigList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorUnbondingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorUnbondingInfo == nil {
				m.DelegatorUnbondingInfo = &DelegatorUnbondingInfo{}
			}
			if err := m.DelegatorUnbondingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dels = append(m.Dels, &BTCDelegation{})
			if err := m.Dels[len(m.Dels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegationIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegationIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegationIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTxHashList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTxHashList = append(m.StakingTxHashList, make([]byte, postIndex-iNdEx))
			copy(m.StakingTxHashList[len(m.StakingTxHashList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.Pk = &v
			if err := m.Pk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340Signature
			m.Sig = &v
			if err := m.Sig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CovenantAdaptorSignatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CovenantAdaptorSignatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CovenantAdaptorSignatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.CovPk = &v
			if err := m.CovPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptorSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdaptorSigs = append(m.AdaptorSigs, make([]byte, postIndex-iNdEx))
			copy(m.AdaptorSigs[len(m.AdaptorSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelectiveSlashingEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelectiveSlashingEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelectiveSlashingEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpBtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.FpBtcPk = &v
			if err := m.FpBtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveredFpBtcSk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveredFpBtcSk = append(m.RecoveredFpBtcSk[:0], dAtA[iNdEx:postIndex]...)
			if m.RecoveredFpBtcSk == nil {
				m.RecoveredFpBtcSk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InclusionProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InclusionProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InclusionProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &types1.TransactionKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LargestBtcReOrg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LargestBtcReOrg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LargestBtcReOrg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDiff", wireType)
			}
			m.BlockDiff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDiff |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackFrom == nil {
				m.RollbackFrom = &types2.BTCHeaderInfo{}
			}
			if err := m.RollbackFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackTo == nil {
				m.RollbackTo = &types2.BTCHeaderInfo{}
			}
			if err := m.RollbackTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdditionalStakerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdditionalStakerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdditionalStakerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerBtcPkList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonlabs_io_babylon_v4_types.BIP340PubKey
			m.StakerBtcPkList = append(m.StakerBtcPkList, v)
			if err := m.StakerBtcPkList[len(m.StakerBtcPkList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerQuorum", wireType)
			}
			m.StakerQuorum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakerQuorum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorSlashingSigs = append(m.DelegatorSlashingSigs, &SignatureInfo{})
			if err := m.DelegatorSlashingSigs[len(m.DelegatorSlashingSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorUnbondingSlashingSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorUnbondingSlashingSigs = append(m.DelegatorUnbondingSlashingSigs, &SignatureInfo{})
			if err := m.DelegatorUnbondingSlashingSigs[len(m.DelegatorUnbondingSlashingSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBtcstaking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBtcstaking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBtcstaking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBtcstaking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBtcstaking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBtcstaking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBtcstaking = fmt.Errorf("proto: unexpected end of group")
)
