// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/btcstaking/v1/packet.proto

package types

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/x/staking/types"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SlashedFinalityProvider carries a slashed finality provider on a consumer
type SlashedFinalityProvider struct {
	// btc_pk_hex is the Bitcoin secp256k1 PK of this finality provider
	// the PK follows encoding in BIP-340 spec in hex format
	BtcPkHex string `protobuf:"bytes,1,opt,name=btc_pk_hex,json=btcPkHex,proto3" json:"btc_pk_hex,omitempty"`
	// recovered_fp_btc_sk is the finality provider's BTC SK extracted due to slashing
	// this allows the consumer to verify the BTC delegation is indeed slashed
	RecoveredFpBtcSk string `protobuf:"bytes,2,opt,name=recovered_fp_btc_sk,json=recoveredFpBtcSk,proto3" json:"recovered_fp_btc_sk,omitempty"`
}

func (m *SlashedFinalityProvider) Reset()         { *m = SlashedFinalityProvider{} }
func (m *SlashedFinalityProvider) String() string { return proto.CompactTextString(m) }
func (*SlashedFinalityProvider) ProtoMessage()    {}
func (*SlashedFinalityProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{0}
}
func (m *SlashedFinalityProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashedFinalityProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashedFinalityProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashedFinalityProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashedFinalityProvider.Merge(m, src)
}
func (m *SlashedFinalityProvider) XXX_Size() int {
	return m.Size()
}
func (m *SlashedFinalityProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashedFinalityProvider.DiscardUnknown(m)
}

var xxx_messageInfo_SlashedFinalityProvider proto.InternalMessageInfo

func (m *SlashedFinalityProvider) GetBtcPkHex() string {
	if m != nil {
		return m.BtcPkHex
	}
	return ""
}

func (m *SlashedFinalityProvider) GetRecoveredFpBtcSk() string {
	if m != nil {
		return m.RecoveredFpBtcSk
	}
	return ""
}

// BTCStakingIBCPacket is an IBC packet sent from Babylon to a consumer
// It carries a set of events related to BTC staking for a given consumer
// It will be constructed and sent upon `EndBlock` of ZoneConcierge
// (if there are any BTC staking events for a consumer)
type BTCStakingIBCPacket struct {
	NewFp       []*NewFinalityProvider   `protobuf:"bytes,1,rep,name=new_fp,json=newFp,proto3" json:"new_fp,omitempty"`
	ActiveDel   []*ActiveBTCDelegation   `protobuf:"bytes,2,rep,name=active_del,json=activeDel,proto3" json:"active_del,omitempty"`
	UnbondedDel []*UnbondedBTCDelegation `protobuf:"bytes,3,rep,name=unbonded_del,json=unbondedDel,proto3" json:"unbonded_del,omitempty"`
}

func (m *BTCStakingIBCPacket) Reset()         { *m = BTCStakingIBCPacket{} }
func (m *BTCStakingIBCPacket) String() string { return proto.CompactTextString(m) }
func (*BTCStakingIBCPacket) ProtoMessage()    {}
func (*BTCStakingIBCPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{1}
}
func (m *BTCStakingIBCPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCStakingIBCPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCStakingIBCPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCStakingIBCPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCStakingIBCPacket.Merge(m, src)
}
func (m *BTCStakingIBCPacket) XXX_Size() int {
	return m.Size()
}
func (m *BTCStakingIBCPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCStakingIBCPacket.DiscardUnknown(m)
}

var xxx_messageInfo_BTCStakingIBCPacket proto.InternalMessageInfo

func (m *BTCStakingIBCPacket) GetNewFp() []*NewFinalityProvider {
	if m != nil {
		return m.NewFp
	}
	return nil
}

func (m *BTCStakingIBCPacket) GetActiveDel() []*ActiveBTCDelegation {
	if m != nil {
		return m.ActiveDel
	}
	return nil
}

func (m *BTCStakingIBCPacket) GetUnbondedDel() []*UnbondedBTCDelegation {
	if m != nil {
		return m.UnbondedDel
	}
	return nil
}

// NewFinalityProvider is an IBC packet sent from Babylon to consumer
// upon a newly registered finality provider on this consumer
type NewFinalityProvider struct {
	// description defines the description terms for the finality provider.
	Description *types.Description `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// commission defines the commission rate of the finality provider.
	// It forms as a string converted from "cosmossdk.io/math.LegacyDec"
	Commission string `protobuf:"bytes,2,opt,name=commission,proto3" json:"commission,omitempty"`
	// addr is the bech32 address identifier of the finality provider.
	Addr string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	// btc_pk_hex is the Bitcoin secp256k1 PK of this finality provider
	// the PK follows encoding in BIP-340 spec in hex format
	BtcPkHex string `protobuf:"bytes,4,opt,name=btc_pk_hex,json=btcPkHex,proto3" json:"btc_pk_hex,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossessionBTC `protobuf:"bytes,5,opt,name=pop,proto3" json:"pop,omitempty"`
	// bsn_id is the ID of the BSN the finality provider is operating on.
	// If it's missing / empty, it's assumed the finality provider is operating in Babylon.
	BsnId string `protobuf:"bytes,8,opt,name=bsn_id,json=bsnId,proto3" json:"bsn_id,omitempty"`
}

func (m *NewFinalityProvider) Reset()         { *m = NewFinalityProvider{} }
func (m *NewFinalityProvider) String() string { return proto.CompactTextString(m) }
func (*NewFinalityProvider) ProtoMessage()    {}
func (*NewFinalityProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{2}
}
func (m *NewFinalityProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewFinalityProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewFinalityProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewFinalityProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewFinalityProvider.Merge(m, src)
}
func (m *NewFinalityProvider) XXX_Size() int {
	return m.Size()
}
func (m *NewFinalityProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_NewFinalityProvider.DiscardUnknown(m)
}

var xxx_messageInfo_NewFinalityProvider proto.InternalMessageInfo

func (m *NewFinalityProvider) GetDescription() *types.Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *NewFinalityProvider) GetCommission() string {
	if m != nil {
		return m.Commission
	}
	return ""
}

func (m *NewFinalityProvider) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *NewFinalityProvider) GetBtcPkHex() string {
	if m != nil {
		return m.BtcPkHex
	}
	return ""
}

func (m *NewFinalityProvider) GetPop() *ProofOfPossessionBTC {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *NewFinalityProvider) GetBsnId() string {
	if m != nil {
		return m.BsnId
	}
	return ""
}

// ActiveBTCDelegation is an IBC packet sent from Babylon to consumer
// upon a BTC delegation newly receives covenant signatures and thus becomes active
type ActiveBTCDelegation struct {
	// staker_addr is the address to receive rewards from BTC delegation.
	StakerAddr string `protobuf:"bytes,1,opt,name=staker_addr,json=stakerAddr,proto3" json:"staker_addr,omitempty"`
	// btc_pk_hex is the Bitcoin secp256k1 PK of this BTC delegation
	// the PK follows encoding in BIP-340 spec in hex format
	BtcPkHex string `protobuf:"bytes,2,opt,name=btc_pk_hex,json=btcPkHex,proto3" json:"btc_pk_hex,omitempty"`
	// fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
	// this BTC delegation delegates to
	FpBtcPkList []string `protobuf:"bytes,3,rep,name=fp_btc_pk_list,json=fpBtcPkList,proto3" json:"fp_btc_pk_list,omitempty"`
	// start_height is the start BTC height of the BTC delegation
	// it is the start BTC height of the timelock
	StartHeight uint32 `protobuf:"varint,4,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is the end height of the BTC delegation
	// it is the end BTC height of the timelock - w
	EndHeight uint32 `protobuf:"varint,5,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// total_sat is the total amount of BTC stakes in this delegation
	// quantified in satoshi
	TotalSat uint64 `protobuf:"varint,6,opt,name=total_sat,json=totalSat,proto3" json:"total_sat,omitempty"`
	// staking_tx is the staking tx
	StakingTx []byte `protobuf:"bytes,7,opt,name=staking_tx,json=stakingTx,proto3" json:"staking_tx,omitempty"`
	// slashing_tx is the slashing tx
	SlashingTx []byte `protobuf:"bytes,8,opt,name=slashing_tx,json=slashingTx,proto3" json:"slashing_tx,omitempty"`
	// delegator_slashing_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk) as string hex.
	// It will be a part of the witness for the staking tx output.
	DelegatorSlashingSig []byte `protobuf:"bytes,9,opt,name=delegator_slashing_sig,json=delegatorSlashingSig,proto3" json:"delegator_slashing_sig,omitempty"`
	// covenant_sigs is a list of adaptor signatures on the slashing tx
	// by each covenant member
	// It will be a part of the witness for the staking tx output.
	CovenantSigs []*CovenantAdaptorSignatures `protobuf:"bytes,10,rep,name=covenant_sigs,json=covenantSigs,proto3" json:"covenant_sigs,omitempty"`
	// staking_output_idx is the index of the staking output in the staking tx
	StakingOutputIdx uint32 `protobuf:"varint,11,opt,name=staking_output_idx,json=stakingOutputIdx,proto3" json:"staking_output_idx,omitempty"`
	// unbonding_time used in unbonding output timelock path and in slashing transactions
	// change outputs
	UnbondingTime uint32 `protobuf:"varint,12,opt,name=unbonding_time,json=unbondingTime,proto3" json:"unbonding_time,omitempty"`
	// undelegation_info is the undelegation info of this delegation.
	UndelegationInfo *BTCUndelegationInfo `protobuf:"bytes,13,opt,name=undelegation_info,json=undelegationInfo,proto3" json:"undelegation_info,omitempty"`
	// params version used to validate delegation
	ParamsVersion uint32 `protobuf:"varint,14,opt,name=params_version,json=paramsVersion,proto3" json:"params_version,omitempty"`
}

func (m *ActiveBTCDelegation) Reset()         { *m = ActiveBTCDelegation{} }
func (m *ActiveBTCDelegation) String() string { return proto.CompactTextString(m) }
func (*ActiveBTCDelegation) ProtoMessage()    {}
func (*ActiveBTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{3}
}
func (m *ActiveBTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveBTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveBTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveBTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveBTCDelegation.Merge(m, src)
}
func (m *ActiveBTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *ActiveBTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveBTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveBTCDelegation proto.InternalMessageInfo

func (m *ActiveBTCDelegation) GetStakerAddr() string {
	if m != nil {
		return m.StakerAddr
	}
	return ""
}

func (m *ActiveBTCDelegation) GetBtcPkHex() string {
	if m != nil {
		return m.BtcPkHex
	}
	return ""
}

func (m *ActiveBTCDelegation) GetFpBtcPkList() []string {
	if m != nil {
		return m.FpBtcPkList
	}
	return nil
}

func (m *ActiveBTCDelegation) GetStartHeight() uint32 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *ActiveBTCDelegation) GetEndHeight() uint32 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *ActiveBTCDelegation) GetTotalSat() uint64 {
	if m != nil {
		return m.TotalSat
	}
	return 0
}

func (m *ActiveBTCDelegation) GetStakingTx() []byte {
	if m != nil {
		return m.StakingTx
	}
	return nil
}

func (m *ActiveBTCDelegation) GetSlashingTx() []byte {
	if m != nil {
		return m.SlashingTx
	}
	return nil
}

func (m *ActiveBTCDelegation) GetDelegatorSlashingSig() []byte {
	if m != nil {
		return m.DelegatorSlashingSig
	}
	return nil
}

func (m *ActiveBTCDelegation) GetCovenantSigs() []*CovenantAdaptorSignatures {
	if m != nil {
		return m.CovenantSigs
	}
	return nil
}

func (m *ActiveBTCDelegation) GetStakingOutputIdx() uint32 {
	if m != nil {
		return m.StakingOutputIdx
	}
	return 0
}

func (m *ActiveBTCDelegation) GetUnbondingTime() uint32 {
	if m != nil {
		return m.UnbondingTime
	}
	return 0
}

func (m *ActiveBTCDelegation) GetUndelegationInfo() *BTCUndelegationInfo {
	if m != nil {
		return m.UndelegationInfo
	}
	return nil
}

func (m *ActiveBTCDelegation) GetParamsVersion() uint32 {
	if m != nil {
		return m.ParamsVersion
	}
	return 0
}

// BTCUndelegationInfo provides all necessary info about the undeleagation
type BTCUndelegationInfo struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower timelock
	// than staking output.
	UnbondingTx []byte `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// slashing_tx is the slashing tx for unbonding transactions
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// finality provider or covenant yet.
	SlashingTx []byte `protobuf:"bytes,2,opt,name=slashing_tx,json=slashingTx,proto3" json:"slashing_tx,omitempty"`
	// delegator_slashing_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the unbonding tx output.
	DelegatorSlashingSig []byte `protobuf:"bytes,3,opt,name=delegator_slashing_sig,json=delegatorSlashingSig,proto3" json:"delegator_slashing_sig,omitempty"`
	// covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
	// by each covenant member
	// It will be a part of the witness for the staking tx output.
	CovenantSlashingSigs []*CovenantAdaptorSignatures `protobuf:"bytes,4,rep,name=covenant_slashing_sigs,json=covenantSlashingSigs,proto3" json:"covenant_slashing_sigs,omitempty"`
	// covenant_unbonding_sig_list is the list of signatures on the unbonding tx
	// by covenant members
	// It must be provided after processing undelegate message by Babylon
	CovenantUnbondingSigList []*SignatureInfo `protobuf:"bytes,5,rep,name=covenant_unbonding_sig_list,json=covenantUnbondingSigList,proto3" json:"covenant_unbonding_sig_list,omitempty"`
	// delegator_unbonding_info is the information about transaction which spent
	// the staking output
	DelegatorUnbondingInfo *DelegatorUnbondingInfo `protobuf:"bytes,6,opt,name=delegator_unbonding_info,json=delegatorUnbondingInfo,proto3" json:"delegator_unbonding_info,omitempty"`
}

func (m *BTCUndelegationInfo) Reset()         { *m = BTCUndelegationInfo{} }
func (m *BTCUndelegationInfo) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegationInfo) ProtoMessage()    {}
func (*BTCUndelegationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{4}
}
func (m *BTCUndelegationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegationInfo.Merge(m, src)
}
func (m *BTCUndelegationInfo) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegationInfo proto.InternalMessageInfo

func (m *BTCUndelegationInfo) GetUnbondingTx() []byte {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

func (m *BTCUndelegationInfo) GetSlashingTx() []byte {
	if m != nil {
		return m.SlashingTx
	}
	return nil
}

func (m *BTCUndelegationInfo) GetDelegatorSlashingSig() []byte {
	if m != nil {
		return m.DelegatorSlashingSig
	}
	return nil
}

func (m *BTCUndelegationInfo) GetCovenantSlashingSigs() []*CovenantAdaptorSignatures {
	if m != nil {
		return m.CovenantSlashingSigs
	}
	return nil
}

func (m *BTCUndelegationInfo) GetCovenantUnbondingSigList() []*SignatureInfo {
	if m != nil {
		return m.CovenantUnbondingSigList
	}
	return nil
}

func (m *BTCUndelegationInfo) GetDelegatorUnbondingInfo() *DelegatorUnbondingInfo {
	if m != nil {
		return m.DelegatorUnbondingInfo
	}
	return nil
}

// UnbondedBTCDelegation is an IBC packet sent from Babylon to consumer
// upon an early unbonded BTC delegation
type UnbondedBTCDelegation struct {
	// staking tx hash of the BTC delegation. It uniquely identifies a BTC delegation
	StakingTxHash string `protobuf:"bytes,1,opt,name=staking_tx_hash,json=stakingTxHash,proto3" json:"staking_tx_hash,omitempty"`
	// unbonding_tx_sig is the signature on the unbonding tx signed by the BTC delegator
	// It proves that the BTC delegator wants to unbond
	UnbondingTxSig []byte `protobuf:"bytes,2,opt,name=unbonding_tx_sig,json=unbondingTxSig,proto3" json:"unbonding_tx_sig,omitempty"`
	// stake_spending_tx is the stake spending tx
	StakeSpendingTx []byte `protobuf:"bytes,3,opt,name=stake_spending_tx,json=stakeSpendingTx,proto3" json:"stake_spending_tx,omitempty"`
	// proof is the inclusion proof for the stake spending tx
	Proof *InclusionProof `protobuf:"bytes,4,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *UnbondedBTCDelegation) Reset()         { *m = UnbondedBTCDelegation{} }
func (m *UnbondedBTCDelegation) String() string { return proto.CompactTextString(m) }
func (*UnbondedBTCDelegation) ProtoMessage()    {}
func (*UnbondedBTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{5}
}
func (m *UnbondedBTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondedBTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondedBTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondedBTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondedBTCDelegation.Merge(m, src)
}
func (m *UnbondedBTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *UnbondedBTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondedBTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondedBTCDelegation proto.InternalMessageInfo

func (m *UnbondedBTCDelegation) GetStakingTxHash() string {
	if m != nil {
		return m.StakingTxHash
	}
	return ""
}

func (m *UnbondedBTCDelegation) GetUnbondingTxSig() []byte {
	if m != nil {
		return m.UnbondingTxSig
	}
	return nil
}

func (m *UnbondedBTCDelegation) GetStakeSpendingTx() []byte {
	if m != nil {
		return m.StakeSpendingTx
	}
	return nil
}

func (m *UnbondedBTCDelegation) GetProof() *InclusionProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// BTCStakingConsumerEvent defines the structure for storing BTC staking events
// which will be later sent to consumer chains as IBC packets.
type BTCStakingConsumerEvent struct {
	// oneof event represents a mutually exclusive choice among different event types.
	// Only one event type can be set within each BTCStakingEvent message instance.
	//
	// Types that are valid to be assigned to Event:
	//	*BTCStakingConsumerEvent_NewFp
	//	*BTCStakingConsumerEvent_ActiveDel
	//	*BTCStakingConsumerEvent_UnbondedDel
	Event isBTCStakingConsumerEvent_Event `protobuf_oneof:"event"`
}

func (m *BTCStakingConsumerEvent) Reset()         { *m = BTCStakingConsumerEvent{} }
func (m *BTCStakingConsumerEvent) String() string { return proto.CompactTextString(m) }
func (*BTCStakingConsumerEvent) ProtoMessage()    {}
func (*BTCStakingConsumerEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ed0d17ad14d6c0e, []int{6}
}
func (m *BTCStakingConsumerEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCStakingConsumerEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCStakingConsumerEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCStakingConsumerEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCStakingConsumerEvent.Merge(m, src)
}
func (m *BTCStakingConsumerEvent) XXX_Size() int {
	return m.Size()
}
func (m *BTCStakingConsumerEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCStakingConsumerEvent.DiscardUnknown(m)
}

var xxx_messageInfo_BTCStakingConsumerEvent proto.InternalMessageInfo

type isBTCStakingConsumerEvent_Event interface {
	isBTCStakingConsumerEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BTCStakingConsumerEvent_NewFp struct {
	NewFp *NewFinalityProvider `protobuf:"bytes,1,opt,name=new_fp,json=newFp,proto3,oneof" json:"new_fp,omitempty"`
}
type BTCStakingConsumerEvent_ActiveDel struct {
	ActiveDel *ActiveBTCDelegation `protobuf:"bytes,2,opt,name=active_del,json=activeDel,proto3,oneof" json:"active_del,omitempty"`
}
type BTCStakingConsumerEvent_UnbondedDel struct {
	UnbondedDel *UnbondedBTCDelegation `protobuf:"bytes,3,opt,name=unbonded_del,json=unbondedDel,proto3,oneof" json:"unbonded_del,omitempty"`
}

func (*BTCStakingConsumerEvent_NewFp) isBTCStakingConsumerEvent_Event()       {}
func (*BTCStakingConsumerEvent_ActiveDel) isBTCStakingConsumerEvent_Event()   {}
func (*BTCStakingConsumerEvent_UnbondedDel) isBTCStakingConsumerEvent_Event() {}

func (m *BTCStakingConsumerEvent) GetEvent() isBTCStakingConsumerEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *BTCStakingConsumerEvent) GetNewFp() *NewFinalityProvider {
	if x, ok := m.GetEvent().(*BTCStakingConsumerEvent_NewFp); ok {
		return x.NewFp
	}
	return nil
}

func (m *BTCStakingConsumerEvent) GetActiveDel() *ActiveBTCDelegation {
	if x, ok := m.GetEvent().(*BTCStakingConsumerEvent_ActiveDel); ok {
		return x.ActiveDel
	}
	return nil
}

func (m *BTCStakingConsumerEvent) GetUnbondedDel() *UnbondedBTCDelegation {
	if x, ok := m.GetEvent().(*BTCStakingConsumerEvent_UnbondedDel); ok {
		return x.UnbondedDel
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BTCStakingConsumerEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BTCStakingConsumerEvent_NewFp)(nil),
		(*BTCStakingConsumerEvent_ActiveDel)(nil),
		(*BTCStakingConsumerEvent_UnbondedDel)(nil),
	}
}

func init() {
	proto.RegisterType((*SlashedFinalityProvider)(nil), "babylon.btcstaking.v1.SlashedFinalityProvider")
	proto.RegisterType((*BTCStakingIBCPacket)(nil), "babylon.btcstaking.v1.BTCStakingIBCPacket")
	proto.RegisterType((*NewFinalityProvider)(nil), "babylon.btcstaking.v1.NewFinalityProvider")
	proto.RegisterType((*ActiveBTCDelegation)(nil), "babylon.btcstaking.v1.ActiveBTCDelegation")
	proto.RegisterType((*BTCUndelegationInfo)(nil), "babylon.btcstaking.v1.BTCUndelegationInfo")
	proto.RegisterType((*UnbondedBTCDelegation)(nil), "babylon.btcstaking.v1.UnbondedBTCDelegation")
	proto.RegisterType((*BTCStakingConsumerEvent)(nil), "babylon.btcstaking.v1.BTCStakingConsumerEvent")
}

func init() {
	proto.RegisterFile("babylon/btcstaking/v1/packet.proto", fileDescriptor_3ed0d17ad14d6c0e)
}

var fileDescriptor_3ed0d17ad14d6c0e = []byte{
	// 1041 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4b, 0x6f, 0x22, 0x47,
	0x10, 0x66, 0xc0, 0x78, 0x4d, 0x81, 0x1d, 0x6f, 0x7b, 0x1f, 0xa3, 0xdd, 0x84, 0x75, 0xd8, 0x87,
	0xac, 0xcd, 0x2e, 0xc4, 0xce, 0x4a, 0x39, 0x44, 0x39, 0x18, 0xbc, 0x16, 0x28, 0x51, 0xcc, 0x0e,
	0x38, 0x91, 0x72, 0x19, 0xcd, 0xa3, 0x19, 0x5a, 0x0c, 0xd3, 0xa3, 0xe9, 0x06, 0xe3, 0x7b, 0xa4,
	0x5c, 0xf3, 0xa7, 0x22, 0xe5, 0xb8, 0xca, 0x29, 0xc7, 0xc8, 0xfe, 0x0b, 0x39, 0xe5, 0x14, 0x4d,
	0xcd, 0xd3, 0x2c, 0xac, 0xe4, 0xdc, 0xa0, 0xea, 0xab, 0xfa, 0xba, 0xeb, 0xab, 0xea, 0x1a, 0x68,
	0x98, 0x86, 0x79, 0xe9, 0x72, 0xaf, 0x65, 0x4a, 0x4b, 0x48, 0x63, 0xc2, 0x3c, 0xa7, 0x35, 0x3f,
	0x6c, 0xf9, 0x86, 0x35, 0xa1, 0xb2, 0xe9, 0x07, 0x5c, 0x72, 0x72, 0x3f, 0xc6, 0x34, 0x33, 0x4c,
	0x73, 0x7e, 0xf8, 0xe8, 0x99, 0xc5, 0xc5, 0x94, 0x8b, 0x56, 0x16, 0x66, 0x52, 0x69, 0x1c, 0x26,
	0xff, 0xa3, 0xe0, 0x47, 0x4f, 0xd6, 0x10, 0x70, 0x3f, 0x06, 0xbc, 0x58, 0x0d, 0xc8, 0x71, 0x21,
	0xae, 0x31, 0x82, 0x87, 0x03, 0xd7, 0x10, 0x63, 0x6a, 0x9f, 0x32, 0xcf, 0x70, 0x99, 0xbc, 0xec,
	0x07, 0x7c, 0xce, 0x6c, 0x1a, 0x90, 0x4f, 0x01, 0x4c, 0x69, 0xe9, 0xfe, 0x44, 0x1f, 0xd3, 0x85,
	0xaa, 0xec, 0x2b, 0x07, 0x15, 0x6d, 0xcb, 0x94, 0x56, 0x7f, 0xd2, 0xa5, 0x0b, 0xf2, 0x1a, 0xf6,
	0x02, 0x6a, 0xf1, 0x39, 0x0d, 0xa8, 0xad, 0x8f, 0x7c, 0x3d, 0x84, 0x8a, 0x89, 0x5a, 0x44, 0xd8,
	0x6e, 0xea, 0x3a, 0xf5, 0xdb, 0xd2, 0x1a, 0x4c, 0x1a, 0xff, 0x28, 0xb0, 0xd7, 0x1e, 0x76, 0x06,
	0x11, 0x79, 0xaf, 0xdd, 0xe9, 0x63, 0x2d, 0xc8, 0x31, 0x6c, 0x7a, 0xf4, 0x42, 0x1f, 0xf9, 0xaa,
	0xb2, 0x5f, 0x3a, 0xa8, 0x1e, 0xbd, 0x6c, 0xae, 0x2c, 0x4b, 0xf3, 0x07, 0x7a, 0xb1, 0x7c, 0x40,
	0xad, 0xec, 0xd1, 0x8b, 0x53, 0x9f, 0xf4, 0x00, 0x0c, 0x4b, 0xb2, 0x39, 0xd5, 0x6d, 0xea, 0xaa,
	0xc5, 0x8f, 0xa6, 0x39, 0x46, 0x60, 0x7b, 0xd8, 0x39, 0xa1, 0x2e, 0x75, 0x0c, 0xc9, 0xb8, 0xa7,
	0x55, 0xa2, 0xe8, 0x13, 0xea, 0x92, 0x33, 0xa8, 0xcd, 0x3c, 0x93, 0x7b, 0x36, 0xb5, 0x31, 0x59,
	0x09, 0x93, 0xbd, 0x5a, 0x93, 0xec, 0x3c, 0x86, 0xde, 0x4c, 0x57, 0x4d, 0x32, 0x9c, 0x50, 0xb7,
	0xf1, 0x4b, 0x11, 0xf6, 0x56, 0x1c, 0x9d, 0xbc, 0x85, 0xaa, 0x4d, 0x85, 0x15, 0x30, 0x3f, 0x8c,
	0xc1, 0xe2, 0x56, 0x8f, 0x9e, 0x36, 0x23, 0xed, 0x9b, 0x19, 0x07, 0x6a, 0xdf, 0x3c, 0xc9, 0xa0,
	0x5a, 0x3e, 0x8e, 0xd4, 0x01, 0x2c, 0x3e, 0x9d, 0x32, 0x21, 0xc2, 0x2c, 0x51, 0xed, 0x73, 0x16,
	0x42, 0x60, 0xc3, 0xb0, 0xed, 0x40, 0x2d, 0xa1, 0x07, 0x7f, 0x2f, 0xc9, 0xba, 0xb1, 0x24, 0xeb,
	0xb7, 0x50, 0xf2, 0xb9, 0xaf, 0x96, 0xf1, 0x40, 0x5f, 0xac, 0xb9, 0x78, 0x3f, 0xe0, 0x7c, 0x74,
	0x36, 0xea, 0x73, 0x21, 0x28, 0x12, 0xb5, 0x87, 0x1d, 0x2d, 0x8c, 0x23, 0xf7, 0x61, 0xd3, 0x14,
	0x9e, 0xce, 0x6c, 0x75, 0x0b, 0x13, 0x97, 0x4d, 0xe1, 0xf5, 0xec, 0xc6, 0xbf, 0x1b, 0xb0, 0xb7,
	0xa2, 0xf4, 0xe4, 0x09, 0x54, 0xc3, 0xb4, 0x34, 0xd0, 0xf1, 0x98, 0x51, 0x8f, 0x41, 0x64, 0x3a,
	0xfe, 0xf0, 0xb0, 0xc5, 0xa5, 0xc3, 0x3e, 0x85, 0x9d, 0xb8, 0xf3, 0xfc, 0x89, 0xee, 0x32, 0x21,
	0x51, 0xb0, 0x8a, 0x56, 0x1d, 0x85, 0x5d, 0xd7, 0x9f, 0x7c, 0xcf, 0x84, 0x24, 0x9f, 0x43, 0x4d,
	0x48, 0x23, 0x90, 0xfa, 0x98, 0x32, 0x67, 0x2c, 0xf1, 0xc6, 0xdb, 0x5a, 0x15, 0x6d, 0x5d, 0x34,
	0x91, 0xcf, 0x00, 0xa8, 0x67, 0x27, 0x80, 0x32, 0x02, 0x2a, 0xd4, 0xb3, 0x63, 0xf7, 0x63, 0xa8,
	0x48, 0x2e, 0x0d, 0x57, 0x17, 0x86, 0x54, 0x37, 0xf7, 0x95, 0x83, 0x0d, 0x6d, 0x0b, 0x0d, 0x03,
	0x03, 0x63, 0xe3, 0xca, 0xe8, 0x72, 0xa1, 0xde, 0xd9, 0x57, 0x0e, 0x6a, 0x5a, 0x25, 0xb6, 0x0c,
	0x17, 0x78, 0xc3, 0x70, 0xbe, 0x62, 0xff, 0x16, 0xfa, 0x21, 0x31, 0x0d, 0x17, 0xe4, 0x0d, 0x3c,
	0xb0, 0xa3, 0x82, 0xf0, 0x40, 0x4f, 0xa1, 0x82, 0x39, 0x6a, 0x05, 0xb1, 0xf7, 0x52, 0xef, 0x20,
	0x76, 0x0e, 0x98, 0x43, 0xce, 0x61, 0x3b, 0x1c, 0x30, 0xcf, 0xf0, 0x64, 0x88, 0x15, 0x2a, 0x60,
	0xa7, 0x7e, 0xb9, 0x46, 0xb0, 0x4e, 0x8c, 0x3d, 0xb6, 0x0d, 0x3f, 0xcc, 0xc4, 0x1c, 0xcf, 0x90,
	0xb3, 0x80, 0x0a, 0xad, 0x96, 0xa4, 0x19, 0x30, 0x47, 0x90, 0x57, 0x40, 0x92, 0xcb, 0xf0, 0x99,
	0xf4, 0x67, 0x52, 0x67, 0xf6, 0x42, 0xad, 0x62, 0x41, 0x76, 0x63, 0xcf, 0x19, 0x3a, 0x7a, 0xf6,
	0x82, 0x3c, 0x87, 0x9d, 0xa8, 0xd7, 0xf1, 0x72, 0x6c, 0x4a, 0xd5, 0x1a, 0x22, 0xb7, 0x53, 0xeb,
	0x90, 0x4d, 0x29, 0xf9, 0x09, 0xee, 0xce, 0x3c, 0x3b, 0x15, 0x5d, 0x67, 0xde, 0x88, 0xab, 0xdb,
	0xd8, 0x60, 0xeb, 0xc6, 0xb4, 0x3d, 0xec, 0x9c, 0xe7, 0x42, 0x7a, 0xde, 0x88, 0x6b, 0xbb, 0xb3,
	0x25, 0x4b, 0xc8, 0xef, 0x1b, 0x81, 0x31, 0x15, 0xfa, 0x9c, 0x06, 0x38, 0x01, 0x3b, 0x11, 0x7f,
	0x64, 0xfd, 0x31, 0x32, 0x36, 0x7e, 0x2f, 0xe1, 0xd3, 0xb3, 0x9c, 0x30, 0x6c, 0x8c, 0xdc, 0xf1,
	0xa3, 0x17, 0xae, 0x96, 0x8c, 0xef, 0x4a, 0xf5, 0x8a, 0xb7, 0x50, 0xaf, 0xf4, 0x11, 0xf5, 0x46,
	0xf0, 0x20, 0x53, 0x2f, 0x17, 0x24, 0xd4, 0x8d, 0xff, 0x29, 0xe3, 0xbd, 0x54, 0xc6, 0x8c, 0x46,
	0x10, 0x0b, 0x1e, 0xa7, 0x3c, 0xd9, 0x55, 0x05, 0x73, 0xa2, 0x61, 0x29, 0x23, 0xd9, 0xb3, 0x35,
	0x64, 0x69, 0x76, 0xac, 0xbe, 0x9a, 0x24, 0x3a, 0x4f, 0xf2, 0x0c, 0x98, 0x83, 0xf3, 0xe5, 0x80,
	0x9a, 0x95, 0x20, 0x63, 0x41, 0x95, 0x37, 0x51, 0xe5, 0xd7, 0x6b, 0x18, 0x4e, 0x92, 0xb0, 0x34,
	0x27, 0x52, 0x65, 0x15, 0xbd, 0x61, 0x6f, 0xfc, 0xa9, 0xc0, 0xfd, 0x95, 0x4f, 0x2e, 0x79, 0x01,
	0x9f, 0x64, 0x33, 0xa8, 0x8f, 0x0d, 0x31, 0x8e, 0x9f, 0x92, 0xed, 0x74, 0x10, 0xbb, 0x86, 0x18,
	0x93, 0x03, 0xd8, 0xcd, 0x2b, 0x8e, 0x3a, 0x45, 0x9a, 0xee, 0xe4, 0x54, 0x0f, 0x15, 0x7a, 0x09,
	0x77, 0xf1, 0x15, 0xd2, 0x85, 0x4f, 0xd3, 0x06, 0x89, 0x24, 0x45, 0x2a, 0x3a, 0x88, 0xed, 0xc3,
	0x05, 0xf9, 0x06, 0xca, 0x7e, 0xf8, 0x20, 0xe2, 0xcb, 0x52, 0x3d, 0x7a, 0xbe, 0xe6, 0xb6, 0x3d,
	0xcf, 0x72, 0x67, 0x61, 0x43, 0xe2, 0xeb, 0xa9, 0x45, 0x31, 0x8d, 0x5f, 0x8b, 0xf0, 0x30, 0xdb,
	0x8b, 0x1d, 0xee, 0x89, 0xd9, 0x94, 0x06, 0x6f, 0xe7, 0xd4, 0x93, 0xa4, 0x93, 0xdb, 0x8d, 0xca,
	0xed, 0x76, 0x63, 0xb7, 0x90, 0x6c, 0xc7, 0xef, 0x96, 0xb6, 0xa3, 0x72, 0xbb, 0xed, 0xd8, 0x2d,
	0xe4, 0xf7, 0xe3, 0xbb, 0x0f, 0xf6, 0xa3, 0x72, 0xdb, 0xfd, 0xd8, 0x2d, 0xdc, 0xd8, 0x90, 0xed,
	0x3b, 0x50, 0xa6, 0xe1, 0x6d, 0xdb, 0xef, 0xfe, 0xb8, 0xaa, 0x2b, 0xef, 0xaf, 0xea, 0xca, 0xdf,
	0x57, 0x75, 0xe5, 0xb7, 0xeb, 0x7a, 0xe1, 0xfd, 0x75, 0xbd, 0xf0, 0xd7, 0x75, 0xbd, 0xf0, 0xf3,
	0xd7, 0x0e, 0x93, 0xe3, 0x99, 0xd9, 0xb4, 0xf8, 0xb4, 0x15, 0x33, 0xb9, 0x86, 0x29, 0x5e, 0x33,
	0x9e, 0xfc, 0x6d, 0xcd, 0xdf, 0xb4, 0x16, 0xf9, 0x4f, 0x1d, 0x79, 0xe9, 0x53, 0x61, 0x6e, 0xe2,
	0x37, 0xce, 0x57, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xad, 0x41, 0x2a, 0x13, 0x8f, 0x09, 0x00,
	0x00,
}

func (m *SlashedFinalityProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashedFinalityProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashedFinalityProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecoveredFpBtcSk) > 0 {
		i -= len(m.RecoveredFpBtcSk)
		copy(dAtA[i:], m.RecoveredFpBtcSk)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.RecoveredFpBtcSk)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BtcPkHex) > 0 {
		i -= len(m.BtcPkHex)
		copy(dAtA[i:], m.BtcPkHex)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.BtcPkHex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCStakingIBCPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCStakingIBCPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCStakingIBCPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnbondedDel) > 0 {
		for iNdEx := len(m.UnbondedDel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnbondedDel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ActiveDel) > 0 {
		for iNdEx := len(m.ActiveDel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActiveDel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NewFp) > 0 {
		for iNdEx := len(m.NewFp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewFp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NewFinalityProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewFinalityProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewFinalityProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BsnId) > 0 {
		i -= len(m.BsnId)
		copy(dAtA[i:], m.BsnId)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.BsnId)))
		i--
		dAtA[i] = 0x42
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BtcPkHex) > 0 {
		i -= len(m.BtcPkHex)
		copy(dAtA[i:], m.BtcPkHex)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.BtcPkHex)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Commission) > 0 {
		i -= len(m.Commission)
		copy(dAtA[i:], m.Commission)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Commission)))
		i--
		dAtA[i] = 0x12
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActiveBTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveBTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveBTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParamsVersion != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.ParamsVersion))
		i--
		dAtA[i] = 0x70
	}
	if m.UndelegationInfo != nil {
		{
			size, err := m.UndelegationInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.UnbondingTime != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.UnbondingTime))
		i--
		dAtA[i] = 0x60
	}
	if m.StakingOutputIdx != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.StakingOutputIdx))
		i--
		dAtA[i] = 0x58
	}
	if len(m.CovenantSigs) > 0 {
		for iNdEx := len(m.CovenantSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DelegatorSlashingSig) > 0 {
		i -= len(m.DelegatorSlashingSig)
		copy(dAtA[i:], m.DelegatorSlashingSig)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.DelegatorSlashingSig)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SlashingTx) > 0 {
		i -= len(m.SlashingTx)
		copy(dAtA[i:], m.SlashingTx)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.SlashingTx)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.StakingTx) > 0 {
		i -= len(m.StakingTx)
		copy(dAtA[i:], m.StakingTx)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.StakingTx)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TotalSat != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.TotalSat))
		i--
		dAtA[i] = 0x30
	}
	if m.EndHeight != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.StartHeight != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FpBtcPkList) > 0 {
		for iNdEx := len(m.FpBtcPkList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FpBtcPkList[iNdEx])
			copy(dAtA[i:], m.FpBtcPkList[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.FpBtcPkList[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BtcPkHex) > 0 {
		i -= len(m.BtcPkHex)
		copy(dAtA[i:], m.BtcPkHex)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.BtcPkHex)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddr) > 0 {
		i -= len(m.StakerAddr)
		copy(dAtA[i:], m.StakerAddr)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.StakerAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegatorUnbondingInfo != nil {
		{
			size, err := m.DelegatorUnbondingInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CovenantUnbondingSigList) > 0 {
		for iNdEx := len(m.CovenantUnbondingSigList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantUnbondingSigList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CovenantSlashingSigs) > 0 {
		for iNdEx := len(m.CovenantSlashingSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CovenantSlashingSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DelegatorSlashingSig) > 0 {
		i -= len(m.DelegatorSlashingSig)
		copy(dAtA[i:], m.DelegatorSlashingSig)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.DelegatorSlashingSig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SlashingTx) > 0 {
		i -= len(m.SlashingTx)
		copy(dAtA[i:], m.SlashingTx)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.SlashingTx)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UnbondingTx) > 0 {
		i -= len(m.UnbondingTx)
		copy(dAtA[i:], m.UnbondingTx)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.UnbondingTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondedBTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondedBTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondedBTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.StakeSpendingTx) > 0 {
		i -= len(m.StakeSpendingTx)
		copy(dAtA[i:], m.StakeSpendingTx)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.StakeSpendingTx)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UnbondingTxSig) > 0 {
		i -= len(m.UnbondingTxSig)
		copy(dAtA[i:], m.UnbondingTxSig)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.UnbondingTxSig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakingTxHash) > 0 {
		i -= len(m.StakingTxHash)
		copy(dAtA[i:], m.StakingTxHash)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.StakingTxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCStakingConsumerEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCStakingConsumerEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCStakingConsumerEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BTCStakingConsumerEvent_NewFp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCStakingConsumerEvent_NewFp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewFp != nil {
		{
			size, err := m.NewFp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *BTCStakingConsumerEvent_ActiveDel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCStakingConsumerEvent_ActiveDel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ActiveDel != nil {
		{
			size, err := m.ActiveDel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BTCStakingConsumerEvent_UnbondedDel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCStakingConsumerEvent_UnbondedDel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnbondedDel != nil {
		{
			size, err := m.UnbondedDel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintPacket(dAtA []byte, offset int, v uint64) int {
	offset -= sovPacket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SlashedFinalityProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BtcPkHex)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.RecoveredFpBtcSk)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *BTCStakingIBCPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NewFp) > 0 {
		for _, e := range m.NewFp {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if len(m.ActiveDel) > 0 {
		for _, e := range m.ActiveDel {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if len(m.UnbondedDel) > 0 {
		for _, e := range m.UnbondedDel {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *NewFinalityProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Commission)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.BtcPkHex)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.BsnId)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *ActiveBTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddr)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.BtcPkHex)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.FpBtcPkList) > 0 {
		for _, s := range m.FpBtcPkList {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.StartHeight != 0 {
		n += 1 + sovPacket(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovPacket(uint64(m.EndHeight))
	}
	if m.TotalSat != 0 {
		n += 1 + sovPacket(uint64(m.TotalSat))
	}
	l = len(m.StakingTx)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.SlashingTx)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.DelegatorSlashingSig)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.CovenantSigs) > 0 {
		for _, e := range m.CovenantSigs {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.StakingOutputIdx != 0 {
		n += 1 + sovPacket(uint64(m.StakingOutputIdx))
	}
	if m.UnbondingTime != 0 {
		n += 1 + sovPacket(uint64(m.UnbondingTime))
	}
	if m.UndelegationInfo != nil {
		l = m.UndelegationInfo.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.ParamsVersion != 0 {
		n += 1 + sovPacket(uint64(m.ParamsVersion))
	}
	return n
}

func (m *BTCUndelegationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnbondingTx)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.SlashingTx)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.DelegatorSlashingSig)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.CovenantSlashingSigs) > 0 {
		for _, e := range m.CovenantSlashingSigs {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if len(m.CovenantUnbondingSigList) > 0 {
		for _, e := range m.CovenantUnbondingSigList {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.DelegatorUnbondingInfo != nil {
		l = m.DelegatorUnbondingInfo.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *UnbondedBTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakingTxHash)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.UnbondingTxSig)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.StakeSpendingTx)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *BTCStakingConsumerEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *BTCStakingConsumerEvent_NewFp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewFp != nil {
		l = m.NewFp.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *BTCStakingConsumerEvent_ActiveDel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveDel != nil {
		l = m.ActiveDel.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *BTCStakingConsumerEvent_UnbondedDel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnbondedDel != nil {
		l = m.UnbondedDel.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func sovPacket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPacket(x uint64) (n int) {
	return sovPacket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SlashedFinalityProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashedFinalityProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashedFinalityProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPkHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BtcPkHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveredFpBtcSk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveredFpBtcSk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCStakingIBCPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCStakingIBCPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCStakingIBCPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewFp = append(m.NewFp, &NewFinalityProvider{})
			if err := m.NewFp[len(m.NewFp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveDel = append(m.ActiveDel, &ActiveBTCDelegation{})
			if err := m.ActiveDel[len(m.ActiveDel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedDel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondedDel = append(m.UnbondedDel, &UnbondedBTCDelegation{})
			if err := m.UnbondedDel[len(m.UnbondedDel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewFinalityProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewFinalityProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewFinalityProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &types.Description{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPkHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BtcPkHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossessionBTC{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BsnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BsnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveBTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveBTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveBTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPkHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BtcPkHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpBtcPkList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FpBtcPkList = append(m.FpBtcPkList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			m.TotalSat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTx = append(m.StakingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.StakingTx == nil {
				m.StakingTx = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashingTx = append(m.SlashingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.SlashingTx == nil {
				m.SlashingTx = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorSlashingSig = append(m.DelegatorSlashingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorSlashingSig == nil {
				m.DelegatorSlashingSig = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantSigs = append(m.CovenantSigs, &CovenantAdaptorSignatures{})
			if err := m.CovenantSigs[len(m.CovenantSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingOutputIdx", wireType)
			}
			m.StakingOutputIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingOutputIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTime", wireType)
			}
			m.UnbondingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UndelegationInfo == nil {
				m.UndelegationInfo = &BTCUndelegationInfo{}
			}
			if err := m.UndelegationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsVersion", wireType)
			}
			m.ParamsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamsVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondingTx = append(m.UnbondingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.UnbondingTx == nil {
				m.UnbondingTx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashingTx = append(m.SlashingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.SlashingTx == nil {
				m.SlashingTx = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorSlashingSig = append(m.DelegatorSlashingSig[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorSlashingSig == nil {
				m.DelegatorSlashingSig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSlashingSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantSlashingSigs = append(m.CovenantSlashingSigs, &CovenantAdaptorSignatures{})
			if err := m.CovenantSlashingSigs[len(m.CovenantSlashingSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantUnbondingSigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CovenantUnbondingSigList = append(m.CovenantUnbondingSigList, &SignatureInfo{})
			if err := m.CovenantUnbondingSigList[len(m.CovenantUnbondingSigList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorUnbondingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegatorUnbondingInfo == nil {
				m.DelegatorUnbondingInfo = &DelegatorUnbondingInfo{}
			}
			if err := m.DelegatorUnbondingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondedBTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondedBTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondedBTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTxSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondingTxSig = append(m.UnbondingTxSig[:0], dAtA[iNdEx:postIndex]...)
			if m.UnbondingTxSig == nil {
				m.UnbondingTxSig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeSpendingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakeSpendingTx = append(m.StakeSpendingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.StakeSpendingTx == nil {
				m.StakeSpendingTx = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &InclusionProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCStakingConsumerEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCStakingConsumerEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCStakingConsumerEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NewFinalityProvider{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &BTCStakingConsumerEvent_NewFp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActiveBTCDelegation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &BTCStakingConsumerEvent_ActiveDel{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedDel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnbondedBTCDelegation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &BTCStakingConsumerEvent_UnbondedDel{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPacket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPacket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPacket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPacket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPacket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPacket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPacket = fmt.Errorf("proto: unexpected end of group")
)
