// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/incentive/events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventsPowerUpdateAtHeight stores a slice of events happened at
// some specific block height, indexed by the block height.
type EventsPowerUpdateAtHeight struct {
	Events []*EventPowerUpdate `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *EventsPowerUpdateAtHeight) Reset()         { *m = EventsPowerUpdateAtHeight{} }
func (m *EventsPowerUpdateAtHeight) String() string { return proto.CompactTextString(m) }
func (*EventsPowerUpdateAtHeight) ProtoMessage()    {}
func (*EventsPowerUpdateAtHeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_78c8437b872382b3, []int{0}
}
func (m *EventsPowerUpdateAtHeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsPowerUpdateAtHeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsPowerUpdateAtHeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsPowerUpdateAtHeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsPowerUpdateAtHeight.Merge(m, src)
}
func (m *EventsPowerUpdateAtHeight) XXX_Size() int {
	return m.Size()
}
func (m *EventsPowerUpdateAtHeight) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsPowerUpdateAtHeight.DiscardUnknown(m)
}

var xxx_messageInfo_EventsPowerUpdateAtHeight proto.InternalMessageInfo

func (m *EventsPowerUpdateAtHeight) GetEvents() []*EventPowerUpdate {
	if m != nil {
		return m.Events
	}
	return nil
}

// EventPowerUpdate is an event that affects voting power distribution
// of BTC rewards, it is indexed by the babylon block height which
// they were processed at the finality voting power table.
type EventPowerUpdate struct {
	// ev is the event that affects voting power distribution
	//
	// Types that are valid to be assigned to Ev:
	//	*EventPowerUpdate_BtcActivated
	//	*EventPowerUpdate_BtcUnbonded
	Ev isEventPowerUpdate_Ev `protobuf_oneof:"ev"`
}

func (m *EventPowerUpdate) Reset()         { *m = EventPowerUpdate{} }
func (m *EventPowerUpdate) String() string { return proto.CompactTextString(m) }
func (*EventPowerUpdate) ProtoMessage()    {}
func (*EventPowerUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_78c8437b872382b3, []int{1}
}
func (m *EventPowerUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPowerUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPowerUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPowerUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPowerUpdate.Merge(m, src)
}
func (m *EventPowerUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventPowerUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPowerUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventPowerUpdate proto.InternalMessageInfo

type isEventPowerUpdate_Ev interface {
	isEventPowerUpdate_Ev()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EventPowerUpdate_BtcActivated struct {
	BtcActivated *EventBTCDelegationActivated `protobuf:"bytes,1,opt,name=btc_activated,json=btcActivated,proto3,oneof" json:"btc_activated,omitempty"`
}
type EventPowerUpdate_BtcUnbonded struct {
	BtcUnbonded *EventBTCDelegationUnbonded `protobuf:"bytes,2,opt,name=btc_unbonded,json=btcUnbonded,proto3,oneof" json:"btc_unbonded,omitempty"`
}

func (*EventPowerUpdate_BtcActivated) isEventPowerUpdate_Ev() {}
func (*EventPowerUpdate_BtcUnbonded) isEventPowerUpdate_Ev()  {}

func (m *EventPowerUpdate) GetEv() isEventPowerUpdate_Ev {
	if m != nil {
		return m.Ev
	}
	return nil
}

func (m *EventPowerUpdate) GetBtcActivated() *EventBTCDelegationActivated {
	if x, ok := m.GetEv().(*EventPowerUpdate_BtcActivated); ok {
		return x.BtcActivated
	}
	return nil
}

func (m *EventPowerUpdate) GetBtcUnbonded() *EventBTCDelegationUnbonded {
	if x, ok := m.GetEv().(*EventPowerUpdate_BtcUnbonded); ok {
		return x.BtcUnbonded
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EventPowerUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EventPowerUpdate_BtcActivated)(nil),
		(*EventPowerUpdate_BtcUnbonded)(nil),
	}
}

// EventBTCDelegationActivated event that activated a BTC delegation.
type EventBTCDelegationActivated struct {
	// FpAddr is the bbn address of the finality provider
	FpAddr string `protobuf:"bytes,1,opt,name=fp_addr,json=fpAddr,proto3" json:"fp_addr,omitempty"`
	// BtcDelAddr is the bbn address of the BTC delegator
	BtcDelAddr string `protobuf:"bytes,2,opt,name=btc_del_addr,json=btcDelAddr,proto3" json:"btc_del_addr,omitempty"`
	// TotalSat the number of satoshis delegated
	TotalSat cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_sat,json=totalSat,proto3,customtype=cosmossdk.io/math.Int" json:"total_sat"`
}

func (m *EventBTCDelegationActivated) Reset()         { *m = EventBTCDelegationActivated{} }
func (m *EventBTCDelegationActivated) String() string { return proto.CompactTextString(m) }
func (*EventBTCDelegationActivated) ProtoMessage()    {}
func (*EventBTCDelegationActivated) Descriptor() ([]byte, []int) {
	return fileDescriptor_78c8437b872382b3, []int{2}
}
func (m *EventBTCDelegationActivated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBTCDelegationActivated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBTCDelegationActivated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBTCDelegationActivated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBTCDelegationActivated.Merge(m, src)
}
func (m *EventBTCDelegationActivated) XXX_Size() int {
	return m.Size()
}
func (m *EventBTCDelegationActivated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBTCDelegationActivated.DiscardUnknown(m)
}

var xxx_messageInfo_EventBTCDelegationActivated proto.InternalMessageInfo

func (m *EventBTCDelegationActivated) GetFpAddr() string {
	if m != nil {
		return m.FpAddr
	}
	return ""
}

func (m *EventBTCDelegationActivated) GetBtcDelAddr() string {
	if m != nil {
		return m.BtcDelAddr
	}
	return ""
}

// EventBTCDelegationUnbonded event that unbonded a BTC delegation.
type EventBTCDelegationUnbonded struct {
	// FpAddr is the bbn address of the finality provider
	FpAddr string `protobuf:"bytes,1,opt,name=fp_addr,json=fpAddr,proto3" json:"fp_addr,omitempty"`
	// BtcDelAddr is the bbn address of the BTC delegator
	BtcDelAddr string `protobuf:"bytes,2,opt,name=btc_del_addr,json=btcDelAddr,proto3" json:"btc_del_addr,omitempty"`
	// TotalSat the number of satoshis unbonded withdraw
	TotalSat cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_sat,json=totalSat,proto3,customtype=cosmossdk.io/math.Int" json:"total_sat"`
}

func (m *EventBTCDelegationUnbonded) Reset()         { *m = EventBTCDelegationUnbonded{} }
func (m *EventBTCDelegationUnbonded) String() string { return proto.CompactTextString(m) }
func (*EventBTCDelegationUnbonded) ProtoMessage()    {}
func (*EventBTCDelegationUnbonded) Descriptor() ([]byte, []int) {
	return fileDescriptor_78c8437b872382b3, []int{3}
}
func (m *EventBTCDelegationUnbonded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBTCDelegationUnbonded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBTCDelegationUnbonded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBTCDelegationUnbonded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBTCDelegationUnbonded.Merge(m, src)
}
func (m *EventBTCDelegationUnbonded) XXX_Size() int {
	return m.Size()
}
func (m *EventBTCDelegationUnbonded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBTCDelegationUnbonded.DiscardUnknown(m)
}

var xxx_messageInfo_EventBTCDelegationUnbonded proto.InternalMessageInfo

func (m *EventBTCDelegationUnbonded) GetFpAddr() string {
	if m != nil {
		return m.FpAddr
	}
	return ""
}

func (m *EventBTCDelegationUnbonded) GetBtcDelAddr() string {
	if m != nil {
		return m.BtcDelAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*EventsPowerUpdateAtHeight)(nil), "babylon.incentive.EventsPowerUpdateAtHeight")
	proto.RegisterType((*EventPowerUpdate)(nil), "babylon.incentive.EventPowerUpdate")
	proto.RegisterType((*EventBTCDelegationActivated)(nil), "babylon.incentive.EventBTCDelegationActivated")
	proto.RegisterType((*EventBTCDelegationUnbonded)(nil), "babylon.incentive.EventBTCDelegationUnbonded")
}

func init() { proto.RegisterFile("babylon/incentive/events.proto", fileDescriptor_78c8437b872382b3) }

var fileDescriptor_78c8437b872382b3 = []byte{
	// 440 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x93, 0xcf, 0x6b, 0xd4, 0x40,
	0x14, 0xc7, 0x33, 0x5b, 0x59, 0xed, 0x6c, 0x05, 0x0d, 0x15, 0xd2, 0x15, 0xd2, 0x65, 0xbd, 0x2c,
	0xc8, 0x26, 0x58, 0xc5, 0x83, 0x9e, 0x36, 0x56, 0xd8, 0xde, 0x4a, 0xea, 0x82, 0x78, 0x09, 0x33,
	0x99, 0xd7, 0xec, 0x60, 0x76, 0x26, 0x64, 0x5e, 0xa3, 0xfd, 0x2f, 0xfc, 0x63, 0xfa, 0x1f, 0x78,
	0xe9, 0xb1, 0x14, 0x14, 0xf1, 0x50, 0x64, 0xf7, 0x1f, 0x91, 0xcd, 0x64, 0x4b, 0x51, 0x56, 0xbd,
	0x7a, 0xcb, 0xf7, 0xbd, 0xf9, 0x7c, 0xdf, 0x0f, 0xf2, 0xa8, 0xcf, 0x19, 0x3f, 0xcd, 0xb5, 0x0a,
	0xa5, 0x4a, 0x41, 0xa1, 0xac, 0x20, 0x84, 0x0a, 0x14, 0x9a, 0xa0, 0x28, 0x35, 0x6a, 0xf7, 0x7e,
	0x93, 0x0f, 0xae, 0xf3, 0xdd, 0x9d, 0x54, 0x9b, 0x99, 0x36, 0x49, 0xfd, 0x20, 0xb4, 0xc2, 0xbe,
	0xee, 0x6e, 0x67, 0x3a, 0xd3, 0x36, 0xbe, 0xfc, 0xb2, 0xd1, 0xfe, 0x5b, 0xba, 0xf3, 0xba, 0xf6,
	0x3c, 0xd4, 0x1f, 0xa0, 0x9c, 0x14, 0x82, 0x21, 0x8c, 0x70, 0x0c, 0x32, 0x9b, 0xa2, 0xfb, 0x92,
	0xb6, 0x6d, 0x41, 0x8f, 0xf4, 0x36, 0x06, 0x9d, 0xbd, 0x47, 0xc1, 0x6f, 0x15, 0x83, 0x9a, 0xbe,
	0x01, 0xc7, 0x0d, 0xd2, 0xff, 0x4c, 0xe8, 0xbd, 0x5f, 0x93, 0xee, 0x84, 0xde, 0xe5, 0x98, 0x26,
	0x2c, 0x45, 0x59, 0x31, 0x04, 0xe1, 0x91, 0x1e, 0x19, 0x74, 0xf6, 0x82, 0x75, 0xc6, 0xd1, 0x9b,
	0x57, 0xfb, 0x90, 0x43, 0xc6, 0x50, 0x6a, 0x35, 0x5a, 0x51, 0x63, 0x27, 0xde, 0xe2, 0x98, 0x5e,
	0x6b, 0x37, 0xa6, 0x4b, 0x9d, 0x9c, 0x28, 0xae, 0x95, 0x00, 0xe1, 0xb5, 0x6a, 0xd7, 0xe1, 0x3f,
	0xb9, 0x4e, 0x1a, 0x68, 0xec, 0xc4, 0x1d, 0x8e, 0xe9, 0x4a, 0x46, 0xb7, 0x68, 0x0b, 0xaa, 0xfe,
	0x57, 0x42, 0x1f, 0xfe, 0xa1, 0x13, 0xf7, 0x09, 0xbd, 0x7d, 0x5c, 0x24, 0x4c, 0x88, 0xb2, 0x1e,
	0x65, 0x33, 0xf2, 0x2e, 0xcf, 0x86, 0xdb, 0xcd, 0xe2, 0x47, 0x42, 0x94, 0x60, 0xcc, 0x11, 0x96,
	0x52, 0x65, 0x71, 0xfb, 0xb8, 0x58, 0x06, 0xdc, 0x17, 0xb6, 0x59, 0x01, 0xb9, 0xe5, 0x5a, 0x7f,
	0xe1, 0x28, 0xc7, 0x74, 0x1f, 0xf2, 0x9a, 0x1d, 0xd3, 0x4d, 0xd4, 0xc8, 0xf2, 0xc4, 0x30, 0xf4,
	0x36, 0x7a, 0x64, 0xb0, 0x15, 0x3d, 0x3e, 0xbf, 0xda, 0x75, 0xbe, 0x5f, 0xed, 0x3e, 0xb0, 0xb0,
	0x11, 0xef, 0x03, 0xa9, 0xc3, 0x19, 0xc3, 0x69, 0x70, 0xa0, 0xf0, 0xf2, 0x6c, 0x48, 0x1b, 0xd7,
	0x03, 0x85, 0xf1, 0x9d, 0x9a, 0x3e, 0x62, 0xd8, 0xff, 0x42, 0x68, 0x77, 0xfd, 0x32, 0xfe, 0xdb,
	0xb9, 0xa2, 0xc3, 0xf3, 0xb9, 0x4f, 0x2e, 0xe6, 0x3e, 0xf9, 0x31, 0xf7, 0xc9, 0xa7, 0x85, 0xef,
	0x5c, 0x2c, 0x7c, 0xe7, 0xdb, 0xc2, 0x77, 0xde, 0x3d, 0xcf, 0x24, 0x4e, 0x4f, 0x78, 0x90, 0xea,
	0x59, 0xd8, 0xfc, 0x18, 0x39, 0xe3, 0x66, 0x28, 0xf5, 0x4a, 0x86, 0xd5, 0xb3, 0xf0, 0xe3, 0x8d,
	0x6b, 0xc3, 0xd3, 0x02, 0x0c, 0x6f, 0xd7, 0x97, 0xf2, 0xf4, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x50, 0x49, 0x68, 0x7b, 0x8f, 0x03, 0x00, 0x00,
}

func (m *EventsPowerUpdateAtHeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsPowerUpdateAtHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsPowerUpdateAtHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventPowerUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPowerUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPowerUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ev != nil {
		{
			size := m.Ev.Size()
			i -= size
			if _, err := m.Ev.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventPowerUpdate_BtcActivated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPowerUpdate_BtcActivated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BtcActivated != nil {
		{
			size, err := m.BtcActivated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EventPowerUpdate_BtcUnbonded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPowerUpdate_BtcUnbonded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BtcUnbonded != nil {
		{
			size, err := m.BtcUnbonded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EventBTCDelegationActivated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBTCDelegationActivated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBTCDelegationActivated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalSat.Size()
		i -= size
		if _, err := m.TotalSat.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BtcDelAddr) > 0 {
		i -= len(m.BtcDelAddr)
		copy(dAtA[i:], m.BtcDelAddr)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BtcDelAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FpAddr) > 0 {
		i -= len(m.FpAddr)
		copy(dAtA[i:], m.FpAddr)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FpAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBTCDelegationUnbonded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBTCDelegationUnbonded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBTCDelegationUnbonded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalSat.Size()
		i -= size
		if _, err := m.TotalSat.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BtcDelAddr) > 0 {
		i -= len(m.BtcDelAddr)
		copy(dAtA[i:], m.BtcDelAddr)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BtcDelAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FpAddr) > 0 {
		i -= len(m.FpAddr)
		copy(dAtA[i:], m.FpAddr)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FpAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventsPowerUpdateAtHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventPowerUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ev != nil {
		n += m.Ev.Size()
	}
	return n
}

func (m *EventPowerUpdate_BtcActivated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BtcActivated != nil {
		l = m.BtcActivated.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventPowerUpdate_BtcUnbonded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BtcUnbonded != nil {
		l = m.BtcUnbonded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventBTCDelegationActivated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FpAddr)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BtcDelAddr)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.TotalSat.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventBTCDelegationUnbonded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FpAddr)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BtcDelAddr)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.TotalSat.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventsPowerUpdateAtHeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsPowerUpdateAtHeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsPowerUpdateAtHeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &EventPowerUpdate{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPowerUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPowerUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPowerUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcActivated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventBTCDelegationActivated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ev = &EventPowerUpdate_BtcActivated{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcUnbonded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventBTCDelegationUnbonded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ev = &EventPowerUpdate_BtcUnbonded{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBTCDelegationActivated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBTCDelegationActivated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBTCDelegationActivated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcDelAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BtcDelAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBTCDelegationUnbonded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBTCDelegationUnbonded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBTCDelegationUnbonded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcDelAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BtcDelAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
